- `프로그래밍 🔥`
  - 프로그래밍이란?
    - 실행을 요구하는 일종의 커뮤니케이션
    - 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 자세 요구를 설명하고 명령하는 것
    - 해결해야 할 문제를 명확히 이해한 후 적절한 문제 해결 방안을 정의할 필요가 있음
    
  - 컴파일러, 인터프리터 (기계어로 번역하는 번역기)
    - 컴파일러 : 소스 코드를 한꺼번에 기계어로 번역하여 실행 가능한 파일을 만듭니다 
    - 인터프리터 : 소스 코드를 한 줄씩 잃고 실행하여 결과를 출력, 컴파일러보다 느리지만 코드 작성과 수정이 더 쉽다

- `자바스크립트란 🔥`
  - 자바스크립트의 특징
    - 웹 브라우저에서 동작하는 유일한 프로그래밍언어
    - 인터프리터, 객체 기반의 스크립트언어

- `변수 🔥`
  - 변수란?
    - 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름 
  - 식별자란(identifier)? 🔥
    - 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름
    - 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름들 (변수, 함수, 클래스 등)
    - 일반적으로 영문,숫자,밑줄로 구성 ex)myVar, total_num ...
  - 변수를 선언한다는 것의 의미
    - 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수있게 준비하는 것
  - var
    - 변수를 의미하는 variable의 약자로, 새로운 변수를 선언할 것을 지시하는 키워드 혹은 명령어
    - 변수 선언하면 메모리 공간에는 비어있는 것이 아니라 undefined가 기본적으로 입력됨
  - 호이스팅이란? 🔥🔥🔥🔥
    - 변수가 어디에 위치하던지와 상관없이 어디서든지 변수를 참조할 수 있게 하는 것
    - 모든 선언문은 런타임 이전 단계에서 먼저 실행되기 때문에, 모든 식별자(변수, 함수, 클래스 등)가 호이스팅이 된다
  - var의 문제점 🔥🔥
    - 변수 중복 선언 허용
    - 함수 레벨 스코프 (if, for, while, try/catch문과 같은 블록 레벨은 지역 스코프로 인정하지않음)
    - 변수 호이스팅 (var는 변수 선언전에도 사용가능하고, let과 const도 호이스팅은 되지만 사용불가)
  - let과 var의 차이 🔥🔥🔥 : let은 ES6에서 도입하였으며 var의 문제점을 보완하였음
    - let은 중복 선언 불가
    - let은 함수 레벨 + 블록 레벨 스코프 (함수와 if, for, while, try/catch문 모두 지역 스코프로 인정)
    - let은 변수 호이스팅이 발생하지 않는 것처럼 동작함 (실제로는 호이스팅이 됨)
    
  - TDZ 🔥🔥🔥 : let과 const가 호이스팅은 되지만 선언문 이전에 사용 불가능 한 이유
    - 선언단계(호이스팅되어 스코프 맨위에서 선언) --> 일시적 사각지대(TDZ) --> 초기화 단계(실제 선언문이 있는부분, undefined으로 초기화) --> 할당 단계
    - var는 TDZ가 존재하지 않아 선언 단계가 곧 초기화 단계가 되어 호이스팅되면 undefind가됨
  - const 🔥🔥
    - 선언과 동시에 초기화해야 한다 (undefined X)
    - 재할당 불가
    - 상수로 사용
  - 식별자 네이밍 규칙
    - 영문 대소문자, 숫자, 언더스코어(_), 달러기호($)만 포함
    - 숫자로 시작할 수 없음
    - 공백 X
    - 예약어 X
    - 대소문자를 구분
  - 네이밍 컨벤션
    - 카멜 케이스 (camelCase) : 첫번째 단어는 소문자, 그 이후 각 단어의 첫글자를 대문자로 ex) firstName
    - 스네이크 케이스 (snake_case) : 모든 단어를 소문자로 적고, 단어 사이를 언더스코어(_)로 구분 ex) student_grade
    - 파스칼 케이스 (PascalCase) : 단어의 첫 글자를 대문자로 적는 방식이며 클래스이름 짓는데 주로사용 ex) FirstName
    - 헝가리언 케이스 (typeHungarianCase) : 타입을 접두사로 앞에 붙이는 방식 ex) strName, nCount
  - 리터럴이란?
    - 변수에 할당할 수 있는 고정된 값 (하드코딩할 수 있는 값)

- `데이터 타입 🔥`
  - 데이터 타입의 종류 🔥 : 원시타입 (number, string, boolean, undefined, null, symbol, bigint) / 객체타입 (object, function, array)
  - 심벌 타입이란?
    - 유일하고 수정불가능한 식별자를 만드는 데 사용 (식별자 중복을 방지하기 위한 용도)
    - ex) const mySymbolWithValue = Symbol('Hello');
  - 데이터 타입이 필요한 이유 🔥
    - 효율적으로 메모리 공간의 크기를 결정하기 위해
    - 2진수를 어떻게 해석할지 결정하기 위해
  - 정적 타이핑
    - 데이터 타입을 사전에 선언(명시적 타입 선언)을 해야함
    - 타입스크립트, C, C++, 자바, 코틀린, 고, 러스트
  - 동적 타이핑
    - 재 할당에 의해 변수의 타입은 언제든지 동적으로 변할 수있음
    - 자바스크립트, 파이썬
    
- `타입변환과 단축 평가 🔥`
  - 명시적 타입 변환이란?
    - 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다 
  - 명시적 타입 변환 함수의 예시
    - String(숫자) , 숫자.toString() 등
  - 암묵적 타입 변환이란?
    - 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 암묵적 타입 변환 또는 강제 타입 변환이라 한다
    - 명시적으로 타입을 변환하는 것보다 간편하지만, 예상치 못한 결과를 초래할 수도 있음
    - ex) const num = "2" + 3   ----> 여기서 num 숫자형 5 ("2"는 문자형이였음)
  - truthy / falsy 한 값이 뭔가요?
    - boolean값이 아니더라 truthy / falsy 하게 암묵적 타입 변환이 이뤄지는것
    - true : 1, "0", " ", 등
    - false : 0, undefined, "", 등

- `배열 🔥`
  - 자바스크립트의 배열과 자료구조의 배열
    - 자바스크립트 : 어떤 타입이든 섞어서 사용가능, 배열 길이 조정가능, 메소드 지원, 희소 배열(sparse array)
    - 자료구조 : 하나의 타입만 가능, 초기선언 배열 길이 유지해야함, 메소드 지원하지 않음, 밀집 배열(dense array)

  - 배열의 메서드
    - 원본 배열을 직접 변경하는 메서드 : push, pop, unshift, shift, splice, join, reverse, fill
    - 새로운 배열을 생성하여 반환하는 메서드 : isArray, indexOf, concat, slice, includes

  - 고차 함수란?
    - 함수를 인수로 전달받거나, 함수를 반환하는 함수
    - 원본 배열을 바탕으로 사용 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 쉽게 새로운 결과값을 창조하는데 유용
    - sort, forEach, map, filter, reduce, some, every, find

  - forEach와 map의 차이
    - 공통점은 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출, 파라미터 순(1 배열의 요소값, 2 인덱스, 3 배열 자기 자신(this))
    - forEach는 단순히 반복문을 대체하기 위한 고차 함수이며, 항상 undefind를 반환
    - map은 새로운 배열을 반환하는 고차 함수

- `객체 리터럴 🔥`
  - 자바스크립트에서 객체란?
    - 함수, 배열, 객체, 정규표현식 등이 객체에 속함
    - 원시 타입은 하나의 값이지만, 객체 타입은 다양한 타입의 값으로 구성한 복합적인 자료구조
  - 함수와 메서드의 차이점
    - 메서드는 객체에 묶여있는 함수를 의
  - 객체를 생성하는 방법
    - 객체 리터럴 : const person = { name: 'John', age: 30, city: 'New York' };
    - Object 생성자 함수 : const person = new Object(); person.name = "John"; person.age = 30;
    - 생성자 함수 : function Person(name, age, city) { this.name = name; this.age = age;}; const person = new Person('John', 30);
    - Object.create 메서드 : const person = Object.create(null); person.name = 'John'; person.age = 30;
    - 클래스(ES6)
  - 전역 객체
    - 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 어떤 환경에서도 접근 가능한 특수한 객체
    - 프로그램 전체에서 공유되는 기본적인 기능들을 제공
    - 브라우저에서는 window 객체, Node.js에서는 global 객체

- `원시 값과 객체 비교 🔥`
  - 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유
    - 원시타입의 값은 변경 불가능한 값이고, 객체(참조)타입의 값은 변경 가능한 값이다
    - 원시값을 변수에 담으면 실제 값이 저장되고, 객체를 변수에 담으면 메모리주소가 저장된다
    - 원시값이 저장된 변수를 다른 변수에 할당하면 이를 값에 의한 전달이라함, 객체가 담긴 변수를 다른변수에 할당하면 이를 참조에 의한 전달이라함.
  - 값에 의한 전달
    - 원시타입의 실제 값을 전달하는것
  - 참조에 의한 전달
    - 객체타입의 주소(참조) 값을 전달하는것

- `함수 🔥`
  - 함수를 정의하는 방법
    - 함수 선언문 
    ```
    function add(x,y){
      return x+y;
    }
    ```
    - 함수 표현식
    ```
    var add = function(x,y){
      return x + y;
    }
    ```
    - 생성자 함수
    ```
    var add = new Function('x','y', 'return x+y');
    ```
    - 화살표 함수
    ```
    var add = (x,y) => x+y;
    ```
  - 함수 선언문과 함수 표현식의 차이
  - 즉시 실행 함수(IIFE)에 대해

- `스코프 🔥`
  - 스코프란? 🔥🔥🔥
  - 스코프의 종류 🔥🔥
  - 렉시컬 스코프란? 🔥
  - 전역 변수로 변수를 선언하면 생기는 문제점

- `생성자 함수에 의한 객체 생성 🔥`
  - 생성자 함수란?
  - 객체 리터럴로 만들 때와의 차이, 생성자 함수쓰는 이유
  - 생성자 함수가 객체(인스턴스)를 생성하는 과정
    - 

- `함수와 일급 객체 🔥`
  - 일급 객체란?
  - 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?
  - 함수형 프로그래밍이란? 🔥🔥
  - 순수 함수와 일반 함수 차이 🔥🔥

- `프로토타입 🔥`
  - 객체지향 프로그래밍 🔥
  - 객체지향 프로그래밍의 특징 🔥
  - 자바스크립트는 객체지향 프로그래밍 언어인가요?
  - 프로토타입이란?
    - 

- `strict mode 🔥`
  - strict mode란?
  - strict mode로 예방할 수 있는 것

- `빌트인 객체 🔥`
  - 빌트인 객체란? 종류는?
  - 래퍼 객체에 대해
    - 

- `this 🔥`
  - this란? 🔥
  - this 바인딩이란? 🔥
  - this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다른지?

- `실행 컨텍스트 🔥`
  - 실행 컨텍스트에 대해 🔥🔥
    - 

- `클로저 🔥`
  - 클로저란? 🔥🔥🔥
  - 클로저 장점 🔥🔥
  - 클로저를 어떻게 생성 지하는지 🔥

- `클래스 🔥`
  - 클래스가 있기전엔 어떻게 객체지향울 구현했는지
  - 생성자 함수와 클래스의 차이
  - 클래스 정의
  - 클래스의 상속
    - 

- `스프레드 문법 🔥`
  - spread 문법이란?
  - 어떤 상황에서 사용?

- `구조 분해 할당 🔥`
  - 구조 분해 할당이란?
  - 구조 분해 할당의 종류
    - 

- `브라우저 렌더링 과정 🔥`
  - 브라우저의 렌더링 과정 🔥
  - 브라우저의 렌더링 과정에서 자바스크립트는 어떻게 동작 🔥
  - `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유

- `DOM 🔥`
  - DOM이란?
  - DOM의 구성?

- `이벤트 🔥`
  - 마우스 이벤트 타입, click 대신 쓸 수있는 이벤트
  - 그 외에 이벤트
  - 이벤트 핸들러를 등록하는 방식
  - 이벤트 전파(propagation)란?
  - 이벤트 위임(delegation)이란? 🔥
  - e.preventDefault
  - e.stopPropagation
    - 

- `타이머 🔥`
  - 호출 스케쥴링이란?
  - 타이머 함수에는 어떤 것들이 있나?
  - 이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우 할 수있는일?
  - 디바운스에 대해
  - 쓰로틀에 대해

- `비동기 프로그래밍 🔥`
  - 동기와 비동기의 차이 🔥🔥
    - 

  - 이벤트 루프와 태스크 큐에 대해 🔥🔥🔥
  - 마이크로태스크 큐에 대해 🔥🔥
  - 태스크 큐와 마이크로태스크 먼저 실행 되는 것 🔥🔥

- `Ajax 🔥`
  - Ajax란?
  - Ajax와 기존 방식의 차이
  - JSON이란?
  - JSON이 제공하는 정적 프로토타입 메서드에 대해
  - Ajax로 HTTP 요청을 보내기 위한 방법
  - XMLHttpRequest와 fetch 메서드의 차이 🔥
    - 

- `REST API 🔥`
  - REST API란?
  - REST API의 구성
  - REST API를 설계하는데 중요한 것
  - HTTP 요청 메서드에 대해
  - HTTP 상태 코드 🔥

- `Promise 🔥`
  - 콜백이란? 🔥
  - 프로미스란? 🔥
  - 프로미스 생성 방법
  - 프로미스의 상태 🔥
  - 프로미스 빌트인 객체가 제공하는 정적 메서드 🔥
    - 

- `제너레이터와 async await 🔥`
  - 제너레이터란? 일반 함수와의 차이는?
  - 제너레이터의 구조
  - async/await 란? 기존의 Promise와의 차이는? 🔥
  - Promise와 async/await의 차이점 한 줄 요약 🔥

- `에러 🔥`
  - 에러처리하는 이유 🔥
  - 에러를 처리하는 방법

- `모듈 🔥`
  - 모듈이란?
    - 
