- `프로그래밍 🔥`
  - 프로그래밍이란?
    - 실행을 요구하는 일종의 커뮤니케이션
    - 0과 1밖에 알지 못하는 기계가 실행할 수 있을 정도로 정확하고 자세 요구를 설명하고 명령하는 것
    - 해결해야 할 문제를 명확히 이해한 후 적절한 문제 해결 방안을 정의할 필요가 있음
    
  - 컴파일러, 인터프리터 (기계어로 번역하는 번역기)
    - 컴파일러 : 소스 코드를 한꺼번에 기계어로 번역하여 실행 가능한 파일을 만듭니다 
    - 인터프리터 : 소스 코드를 한 줄씩 잃고 실행하여 결과를 출력, 컴파일러보다 느리지만 코드 작성과 수정이 더 쉽다

- `자바스크립트란 🔥`
  - 자바스크립트의 특징
    - 웹 브라우저에서 동작하는 유일한 프로그래밍언어
    - 인터프리터, 객체 기반의 스크립트언어

- `변수 🔥`
  - 변수란?
    - 변수는 하나의 값을 저장하기 위해 확보한 메모리 공간 자체 또는 그 공간을 식별하기 위해 붙인 이름 
  - 식별자란(identifier)? 🔥
    - 식별자는 어떤 값을 구별해서 식별할 수 있는 고유한 이름
    - 메모리 상에 존재하는 어떤 값을 식별할 수 있는 이름들 (변수, 함수, 클래스 등)
    - 일반적으로 영문,숫자,밑줄로 구성 ex)myVar, total_num ...
  - 변수를 선언한다는 것의 의미
    - 값을 저장하기 위한 메모리 공간을 확보하고, 변수 이름과 확보된 메모리 공간의 주소를 연결해서 값을 저장할 수있게 준비하는 것
  - var
    - 변수를 의미하는 variable의 약자로, 새로운 변수를 선언할 것을 지시하는 키워드 혹은 명령어
    - 변수 선언하면 메모리 공간에는 비어있는 것이 아니라 undefined가 기본적으로 입력됨
  - 호이스팅이란? 🔥🔥🔥🔥
    - 변수 호이스팅이란 변수가 어디에 위치하던지와 상관없이 어디서든지 변수를 참조할 수 있게 하는 것
    - 모든 선언문은 런타임 이전 단계에서 끌어올려 먼저 실행되기 때문에, 모든 식별자(변수, 함수, 클래스 등)가 호이스팅이 된다
  - var의 문제점 🔥🔥
    - 변수 중복 선언 허용
    - 함수 레벨 스코프 (if, for, while, try/catch문과 같은 블록 레벨은 지역 스코프로 인정하지않음)
    - 변수 호이스팅 (var는 변수 선언전에도 사용가능하고, let과 const도 호이스팅은 되지만 사용불가)
  - let과 var의 차이 🔥🔥🔥 : let은 ES6에서 도입하였으며 var의 문제점을 보완하였음
    - let은 중복 선언 불가
    - let은 함수 레벨 + 블록 레벨 스코프 (함수와 if, for, while, try/catch문 모두 지역 스코프로 인정)
    - let은 변수 호이스팅이 발생하지 않는 것처럼 동작함 (실제로는 호이스팅이 됨)
    
  - TDZ 🔥🔥🔥 : let과 const가 호이스팅은 되지만 선언문 이전에 사용 불가능 한 이유
    - 선언단계(호이스팅되어 스코프 맨위에서 선언) --> 일시적 사각지대(TDZ) --> 초기화 단계(실제 선언문이 있는부분, undefined으로 초기화) --> 할당 단계
    - var는 TDZ가 존재하지 않아 선언 단계가 곧 초기화 단계가 되어 호이스팅되면 undefind가됨
  - const 🔥🔥
    - 선언과 동시에 초기화해야 한다 (undefined X)
    - 재할당 불가
    - 상수로 사용
  - 식별자 네이밍 규칙
    - 영문 대소문자, 숫자, 언더스코어(_), 달러기호($)만 포함
    - 숫자로 시작할 수 없음
    - 공백 X
    - 예약어 X
    - 대소문자를 구분
  - 네이밍 컨벤션
    - 카멜 케이스 (camelCase) : 첫번째 단어는 소문자, 그 이후 각 단어의 첫글자를 대문자로 ex) firstName
    - 스네이크 케이스 (snake_case) : 모든 단어를 소문자로 적고, 단어 사이를 언더스코어(_)로 구분 ex) student_grade
    - 파스칼 케이스 (PascalCase) : 단어의 첫 글자를 대문자로 적는 방식이며 클래스이름 짓는데 주로사용 ex) FirstName
    - 헝가리언 케이스 (typeHungarianCase) : 타입을 접두사로 앞에 붙이는 방식 ex) strName, nCount
  - 리터럴이란?
    - 변수에 할당할 수 있는 고정된 값 (하드코딩할 수 있는 값)

- `데이터 타입 🔥`
  - 데이터 타입의 종류 🔥 : 원시타입 (number, string, boolean, undefined, null, symbol, bigint) / 객체타입 (object, function, array)
  - 심벌 타입이란?
    - 유일하고 수정불가능한 식별자를 만드는 데 사용 (식별자 중복을 방지하기 위한 용도)
    - ex) const mySymbolWithValue = Symbol('Hello');
  - 데이터 타입이 필요한 이유 🔥
    - 효율적으로 메모리 공간의 크기를 결정하기 위해
    - 2진수를 어떻게 해석할지 결정하기 위해
  - 정적 타이핑
    - 데이터 타입을 사전에 선언(명시적 타입 선언)을 해야함
    - 타입스크립트, C, C++, 자바, 코틀린, 고, 러스트
  - 동적 타이핑
    - 재 할당에 의해 변수의 타입은 언제든지 동적으로 변할 수있음
    - 자바스크립트, 파이썬
    
- `타입변환과 단축 평가 🔥`
  - 명시적 타입 변환이란?
    - 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환 또는 타입 캐스팅이라 한다 
  - 명시적 타입 변환 함수의 예시
    - String(숫자) , 숫자.toString() 등
  - 암묵적 타입 변환이란?
    - 개발자의 의도와는 상관없이 자바스크립트 엔진에 의해 암묵적으로 타입이 자동 변환되는 것을 암묵적 타입 변환 또는 강제 타입 변환이라 한다
    - 명시적으로 타입을 변환하는 것보다 간편하지만, 예상치 못한 결과를 초래할 수도 있음
    - ex) const num = "2" + 3   ----> 여기서 num 숫자형 5 ("2"는 문자형이였음)
  - truthy / falsy 한 값이 뭔가요?
    - boolean값이 아니더라 truthy / falsy 하게 암묵적 타입 변환이 이뤄지는것
    - true : 1, "0", " ", 등
    - false : 0, undefined, "", 등

- `배열 🔥`
  - 자바스크립트의 배열과 자료구조의 배열
    - 자바스크립트 : 어떤 타입이든 섞어서 사용가능, 배열 길이 조정가능, 메소드 지원, 희소 배열(sparse array)
    - 자료구조 : 하나의 타입만 가능, 초기선언 배열 길이 유지해야함, 메소드 지원하지 않음, 밀집 배열(dense array)

  - 배열의 메서드
    - 원본 배열을 직접 변경하는 메서드 : push, pop, unshift, shift, splice, join, reverse, fill
    - 새로운 배열을 생성하여 반환하는 메서드 : isArray, indexOf, concat, slice, includes

  - 고차 함수란?
    - 함수를 매개변수로 전달받거나, 함수를 반환하는 함수
    - 원본 배열을 바탕으로 사용 로직 내에 존재하는 조건문과 반복문을 제거하여 복잡성을 해결하고 변수의 사용을 억제하여 쉽게 새로운 결과값을 창조하는데 유용
    - sort, forEach, map, filter, reduce, some, every, find

  - forEach와 map의 차이
    - 공통점은 자신을 호출한 배열의 모든 요소를 순회하면서 인수로 전달받은 콜백 함수를 반복 호출, 파라미터 순(1 배열의 요소값, 2 인덱스, 3 배열 자기 자신(this))
    - forEach는 단순히 반복문을 대체하기 위한 고차 함수이며, 항상 undefind를 반환
    - map은 새로운 배열을 반환하는 고차 함수

- `객체 리터럴 🔥`
  - 자바스크립트에서 객체란?
    - 함수, 배열, 객체, 정규표현식 등이 객체에 속함
    - 원시 타입은 하나의 값이지만, 객체 타입은 다양한 타입의 값으로 구성한 복합적인 자료구조
  - 함수와 메서드의 차이점
    - 메서드는 객체에 묶여있는 함수를 의미
  - 객체를 생성하는 방법
    - 객체 리터럴 : const person = { name: 'John', age: 30, city: 'New York' };
    - Object 생성자 함수 : const person = new Object(); person.name = "John"; person.age = 30;
    - 생성자 함수 : function Person(name, age, city) { this.name = name; this.age = age;}; const person = new Person('John', 30);
    - Object.create 메서드 : const person = Object.create(null); person.name = 'John'; person.age = 30;
    - 클래스(ES6)
  - 전역 객체
    - 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 어떤 환경에서도 접근 가능한 특수한 객체
    - 프로그램 전체에서 공유되는 기본적인 기능들을 제공
    - 브라우저에서는 window 객체, Node.js에서는 global 객체와 같은 호스트 객체들도 전역 객체중 

- `원시 값과 객체 비교 🔥`
  - 동적 타이핑을 지원하는 자바스크립트에서 데이터의 타입을 크게 2개로 나누는 이유
    - 원시타입의 값은 변경 불가능한 값이고, 객체(참조)타입의 값은 변경 가능한 값이다
    - 원시값을 변수에 담으면 실제 값이 저장되고, 객체를 변수에 담으면 메모리주소가 저장된다
    - 원시값이 저장된 변수를 다른 변수에 할당하면 이를 값에 의한 전달이라함, 객체가 담긴 변수를 다른변수에 할당하면 이를 참조에 의한 전달이라함.
  - 값에 의한 전달
    - 원시타입의 실제 값을 전달하는것
  - 참조에 의한 전달
    - 객체타입의 주소(참조) 값을 전달하는것

- `함수 🔥`
  - 함수를 정의하는 방법
    - 함수 선언문 
    ```
    function add(x,y){
      return x+y;
    }
    ```
    - 함수 표현식
    ```
    var add = function(x,y){
      return x + y;
    }
    ```
    - 생성자 함수
    ```
    var add = new Function('x','y', 'return x+y');
    ```
    - 화살표 함수
    ```
    var add = (x,y) => x+y;
    ```
  - 함수 선언문과 함수 표현식의 차이
    - 함수 선언문은 함수 호이스팅에 의해 런타임 전에 맨위로 끌어 올려져 호출 부분이 함수보다 위에 있어도 작동함 (var에의한 변수 호이스팅은 undefined가되지만 함수 호이스팅은 문제없이 호출가능하게 한다)
    - 함수 표현식은 함수 호출 부분이 함수보다 밑에 위치해 있어야 한다 그 이유는 변수에 함수가 담긴것이어서 호이스팅이 되도 var는 undefined가 되고 let,const는 TDZ가 존재하기 때문
  - 즉시 실행 함수(IIFE: Immediately Invoked Function Expression)에 대해
    - 함수 자체는 자신이 작성한 코드를 지역 스코프로 지정 할수있어서 협업시 다른 개발자가 만든 식별자가 내 것과 같거나 하는 코드 충돌을 피하기 위해 쓰임

- `스코프 🔥`
  - 스코프란? 🔥🔥🔥
    - 식별자(변수)가 유효한 범위
  - 스코프의 종류 🔥🔥
    - 지역변수를 위한 지역 스코프와 전역변수를 위한 전역 스코프
  - 렉시컬 스코프(정적 스코프)란? 🔥
    - 함수를 어디서 '호출'했는지가 아닌 어디서 '정의'했는지에 따라 함수의 상위 스코프를 결정하는 것
  - 전역 변수로 변수를 선언하면 생기는 문제점
    - 암묵적 결합 : 변수의 유효범위 즉 스코프가 클수록 가독성은 나빠지고 의도치 않게 상태가 변경 될 수 있는 위험도가 높아짐
    - 메모리 낭비 : 전역 변수로 계속 남아있어서 메모리 사용량이 늘어날 수 있음
    - 의존성 증가: 전역 변수를 사용한 함수는 해당 변수에 의존성을 가지기 때문에 코드 유지 보수나 리팩토링이 어려움
    - 네임스페이스 오염 : 다른 라이브러리나 모듈에서 사용되는 변수 이름과 충돌 할 가능성이 

- `생성자 함수에 의한 객체 생성 🔥`
  - 생성자 함수란?
    - new 연산자와 함께 호출하여 객체를 생성하여 필요한 프로퍼티나 메서드를 정의 할 수 있는 함수
    - 주로 this 키워드를 이용하여 새로운 객체를 생성
    - 일반 함수와 구문적으로 동일하지만 앞에 대문자로 시작하는 이름을 가짐
    - 인스턴스는 생성자 함수에 의헤 생성된 객체를 말함
    - 자바스크립트는  Object, String, Number, Boolean, Function, Array, Date, RegExp, Promise 등의 빌트인 생성자 함수를 제공
  - 객체 리터럴로 만들 때와의 차이, 생성자 함수쓰는 이유
    - 객체 리터럴 방식 : 단 하나의 객체만 생성 (동일한 프로퍼티를 갖는 여러개의 객체를 생성할때 비효율적)
    - 생성자 함수 방식 : 프로퍼티 구조가 동일한 객체 여러 개를 간편하게 생성 (붕어빵 빵틀 같은역할)
  - 생성자 함수가 객체(인스턴스)를 생성하는 과정
    - 생성자 함수 선언 --> 인스턴스 생성 --> 인스턴스 초기화 --> 인스턴스 반환
    ```
    // 1. 생성자 함수 선언
    function Circle(radius) {
      // 3. 인스턴스 초기화
      this.radius = radius;
      this.getDiameter = function () {
        return 2 * this.radius;
      };
      // 4. 생성자 함수를 호출할 때 넣은 인수를 this 바인딩을 통해 프로퍼티에 할당한 뒤, 인스턴스를 반환한다
    }
    // 2. 인스턴스 생성
    const circle1 = new Circle(5); // 반지름이 5인 Circle 객체를 생성
    ```
 
- `함수와 일급 객체 🔥`
  - 일급 객체란?
    - 함수가 하나의 값처럼 다루어질 수 있는 객체
  - 함수가 일급 객체라면, 일급 객체로 뭘 할 수 있나요?
    - 함수 이름 없이 생성가능 (무명의 리터럴)
    - 변수나, 자료구조(객체,배열)에 저장가능
    - 매개변수와 리턴값으로 사용될 수 있음 (고차함수)
  - 함수형 프로그래밍이란? 🔥🔥
    - 외부 상태에 영향받거나 주지않는 순수 함수를 통해 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 안전성을 높이려는 프로그래밍
  - 순수 함수와 일반 함수 차이 🔥🔥
    - 순수 함수는 입력이 같으면 항상 같은 출력을 반환하고, 외부 상태를 의존하지 않는 부작용이 없는 함수
    - 일반 함수는 항상 같은 출력을 반환하지 않을 수 있으며, 외부 상태에 영향받을 수 있음

- `프로토타입 🔥`
  - 객체지향 프로그래밍(OOP, Object Oriented Programing) 🔥
    - 절차지향적이 아닌 독립적 단위, 즉 객체의 집합으로 프로그램을 표현하려는 프로그래밍
  - 객체지향 프로그래밍의 특징 🔥
    - 추상화 (Abstraciton) : 객체의 다양한 속성 중 프로그램에 필요한 속성만 간추려 표현한 것 (클래스가 어떻게 동작하는지 다 알 필요는 없고 사용자는 사용법만 알면됨)
    - 캡슐화 (Encapsulation) : 데이터를 다루는 방법과 목적에 따라 결합, 변수와 함수를 하나로 묶음
    - 상속 (Inheritance) : 포괄적으로 쓰이는 부모부분을 여러 자식들이 물려받아 동일하게 사용하게 
    - 다형성 (Polymorphism) : 부모클레스에서 물려받은 가상 함수를 자식 클래스 내에서 오버라이딩 되어 사용되는 것
  - 자바스크립트는 객체지향 프로그래밍 언어인가요?
    - 객체지향 프로그래밍 + 함수형 프로그래밍
    - 자바스크립트는 클래스 기반 객체지향 (ES6), 프로토타입 기반 객체지향 (ES5 이전) 둘다 지원
  - 프로토타입이란?
    - 객체 간에 상속을 구현하기 위해 사용되는 객체이고, 그 객체를 참조하는 숨겨논 링크를 제공함
    - 마치 유전자와 같음

    ```
    // 클래스 형식
    class Person {
      constructor(name, age) {
        this.name = name;
        this.age = age;
      }
      sayHello() {
        console.log(`Hello, my name is ${this.name}.`);
      }
    }
    
    const person1 = new Person('John', 30);
    person1.sayHello(); // "Hello, my name is John."

    // 프로토타입 형식 (함수)
    function Person(name, age) {
      this.name = name;
      this.age = age;
    }
    
      Person.prototype.sayHello = function() {
      console.log(`Hello, my name is ${this.name}.`);
    }
    
    const person1 = new Person('John', 30);
    person1.sayHello(); // "Hello, my name is John."
    ```
    
- `strict mode 🔥`
  - strict mode란?
    - 오타나 문법 지식의 미비로 인한 실수를 줄여 안정적인 코드를 생산하기 위해 ES5에서 추가된 모드
    - 오류 발생 할 가능성이 높거나, 자바스크립트 엔진의 최적화 작업에 문제를 일으킬 수 있는 코드에 대해 명시적인 에러를 발생시킴
  - strict mode로 예방할 수 있는 것
    - 전역변수의 묵시적 선언 예방
    - 삭제하면 안되는 변수, 함수, 매개변수가 삭제 되려할 떄 예방
    - 매개변수 이름의 중복 예방

- `빌트인 객체 🔥`
  - 빌트인 객체란, 종류는?
    - 자바스크립트에서 기본적으로 제공하는 객체 (전역 객체랑 다름)
    - Math나 String 등 같은 객체는 빌트인 객체에 해당 (window 객체나 global 객체는 호스트 객체다다)
  - 자바스크립트의 객체 
    - 표준 빌트인 객체 : ECMAScript(ES) 사양에 정의된 표준 객체
    - 호스트 객체 : ECMAScript(ES) 사양에 정의되있진 않지만 실행 환경(브라우저나 Node.js)에서 추가로 제공하는 객체
    - 사용자 정의 객체 : 사용자가 직접 정의한 객체
  - 래퍼 객체(wrapper object)에 대해
    - 원시 타입(문자형,숫자형,불린형)을 마치 객체 타입처럼 사용하는 과정 속에서 생기는 임시 객체
    - 객체처럼 마침표 연산자 (.) 로 접근 및 메서드 호출 가능      ex) let str = "hello";  str.length;  --> str는 문자형인데 래퍼 객체가 생겨서 객체처럼 연산자 (.)를 사용했음
    - 프로퍼티에 접근 및 메서드 호출 한 후 다시 원시값으로 되돌린다

- `this 🔥`
  - this란? 🔥
    - 자신이 생성할 인스턴스를 가리키는 자기 참조 변수
    - this 바인딩은 함수 호출 방식에 의해 동적으로 결정된다.
  - this 바인딩이란? 🔥
    - this가 가리킬 객체와 바인딩하는 것
  - this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다른지?
    - 암시적 바인딩 : 함수를 호출 한 객체와 바인딩 되는 것
    - 명시적 바인딩 : call(), apply(), bind() 함수로 지정해서 바인딩 해주는 것

- `실행 컨텍스트(excute context) 🔥`
  - 실행 컨텍스트에 대해 🔥🔥
    - 코드를 실행하는 데 필요한 환경을 제공하는 객체, 식별자 결정을 더욱 효율적으로 하기 위한 수단
    - 렉시컬 환경은 실행 컨텍스트를 구성하는 하나의 컴포넌트로, 실행 컨텍스트는 호출 스택(Call Stack)에 쌓이며 L.I.F.O(Last In First Out) 방식대로 실행됩니다. 이 때, 호출된 함수의 렉시컬 환경은 해당 함수의 스코프(Scope)를 결정하게 됩니다.

- `클로저 🔥`
  - 클로저란? 🔥🔥🔥
    - 함수가 선언될 당시의 환경을 계속 기억하는 함수
    - 참조하는 식별자를 실행 컨텍스트가 종료되어도 렉시컬 환경을 통해 참조하고, 값을 변경할 수 있게 하는 체인 관계 구조
  - 클로저 장점 🔥🔥
    - 상태가 의도치 않게 변경되지 않도록 상태를 안전하게 은닉하고 특정 함수에게만 상태변경을 허용
  - 클로저를 어떻게 생성 하는지 🔥
    - 내부 함수가 외부 함수의 스코프에서 실행
    - 내부 함수가 외부 함수의 리턴 값으로 사용
    - 내부 함수가 외부 함수의 식별자를 참조할떄
  - 클로저가 되는 유일한 경우 (경우3)
    - 경우1) 상위 스코프 식별자 참조 없이, 외부 함수 내에 내부(중첩) 함수가 외부 함수의 리턴 값으로 사용될 때 -----> 참조 하지도 않은 식별자를 기억하는건 메모리 낭비 (클로저X)
    - 경우2) 내부(중첩) 함수를 리턴 함 없이 내부 함수가 외부 함수의 스코프에서 실행 -----> 외부 함수보다 항상 일찍 소멸되어  (클로저X)
    - 경우3) 상위 스코프의 식별자를 참조하고, 내부(중첩) 함수가 반환되는 경우

- `클래스 🔥`
  - 클래스가 있기전엔 어떻게 객체지향울 구현했는지
  - 생성자 함수와 클래스의 차이
  - 클래스 정의
  - 클래스의 상속
    - 

- `스프레드 문법 🔥`
  - spread 문법이란?
  - 어떤 상황에서 사용?

- `구조 분해 할당 🔥`
  - 구조 분해 할당이란?
  - 구조 분해 할당의 종류
    - 

- `브라우저 렌더링 과정 🔥`
  - 브라우저의 렌더링 과정 🔥
  - 브라우저의 렌더링 과정에서 자바스크립트는 어떻게 동작 🔥
  - `<script></script>` 태그를 `<body></body>` 태그 밑에 둬야하는 이유

- `DOM 🔥`
  - DOM이란?
  - DOM의 구성?

- `이벤트 🔥`
  - 마우스 이벤트 타입, click 대신 쓸 수있는 이벤트
  - 그 외에 이벤트
  - 이벤트 핸들러를 등록하는 방식
  - 이벤트 전파(propagation)란?
  - 이벤트 위임(delegation)이란? 🔥
  - e.preventDefault
  - e.stopPropagation
    - 

- `타이머 🔥`
  - 호출 스케쥴링이란?
  - 타이머 함수에는 어떤 것들이 있나?
  - 이벤트가 과도하게 호출되어 성능에 문제를 일으킬 경우 할 수있는일?
  - 디바운스에 대해
  - 쓰로틀에 대해

- `비동기 프로그래밍 🔥`
  - 동기와 비동기의 차이 🔥🔥
    - 

  - 이벤트 루프와 태스크 큐에 대해 🔥🔥🔥
  - 마이크로태스크 큐에 대해 🔥🔥
  - 태스크 큐와 마이크로태스크 먼저 실행 되는 것 🔥🔥

- `Ajax 🔥`
  - Ajax란?
  - Ajax와 기존 방식의 차이
  - JSON이란?
  - JSON이 제공하는 정적 프로토타입 메서드에 대해
  - Ajax로 HTTP 요청을 보내기 위한 방법
  - XMLHttpRequest와 fetch 메서드의 차이 🔥
    - 

- `REST API 🔥`
  - REST API란?
  - REST API의 구성
  - REST API를 설계하는데 중요한 것
  - HTTP 요청 메서드에 대해
  - HTTP 상태 코드 🔥

- `Promise 🔥`
  - 콜백이란? 🔥
  - 프로미스란? 🔥
  - 프로미스 생성 방법
  - 프로미스의 상태 🔥
  - 프로미스 빌트인 객체가 제공하는 정적 메서드 🔥
    - 

- `제너레이터와 async await 🔥`
  - 제너레이터란? 일반 함수와의 차이는?
  - 제너레이터의 구조
  - async/await 란? 기존의 Promise와의 차이는? 🔥
  - Promise와 async/await의 차이점 한 줄 요약 🔥

- `에러 🔥`
  - 에러처리하는 이유 🔥
  - 에러를 처리하는 방법

- `모듈 🔥`
  - 모듈이란?
    - 
