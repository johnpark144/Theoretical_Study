- [리액트는 라이브러리인가요 프레임워크인가요](#리액트는-라이브러리인가요-프레임워크인가요)
  - 프레임워크 : 개발시 코드의 품질, 필수코드, 알고리즘, 암호화, 데이터베이스 연동 같은 기능들이 어느정도 구성되어 뼈대를 제공하는 것 (개발자를 call)
  - 라이브러리 : 특정 기능에 대한 API를 모은 집합체 (개발자가 call)
  - 프레임워크, 라이브러리 차이 : flow의 차이 (라이브러리는 어플리캐이션의 흐름을 제어하고, 프레임워크의 경우 거꾸로 애플리캐이션이 프레임워크의 흐름대로 사용됨)

- [리액트를 사용하는 이유](#리액트를-사용하는-이유)
  -  컴포넌트를 사용해서 역할과 기능에 따라 따로 관리 용이하다, 반복되는 부분을 한 코드로 재사용 가능하다, 블록쌓기처럼 컴포넌트를 쌓아 빠르고 효율적으로 화면을 구성할수 있다.
  -  전체 페이지를 렌더링 하는게 아니라 Virtual DOM으로 확인된 수정된 부분만 빠르게 렌더링함
  -  SPA로 서버에 부담을 줄이고, 더 좋은 UX를 느낄 수있음
  -  생태계가 넓고, 다양한 라이브러리 사용 가능
  -  리액트 네이티브로 앱 계발도 쉽게 배울 수 있음

- [virtual DOM에 대해서 아나요](#virtual-DOM에-대해서-아나요)
  - 기본 DOM
    - XML이나 HTML 문서에 접근하기 위한 일종의 인터페이스
    - 트리형으로 구조화 되있음
    - 프로그래밍 언어는 DOM구조에 접근 할 수있게 하여 구조,스타일,내용들을 변경할 수있도록 돕는다.
    - HTTP response > DOM tree > CSSOM tree > render tree > painting 형태로 렌더링을 해주는데, DOM 자체의 속도는 느리지 않지만, 잦은 렌더링으로 퍼포먼스가 떨어질 수있음
  - 가상 DOM
    - 가상 DOM은 실제 DOM이 아닌 실제와 같은 사본 DOM으로써, 하나는 변경 이전 내용을 담고있고 하나는 변경 이후에 보여질 내용을 담는다.
    - 변경 전과 후 가상 DOM을 비교하여 바뀐 부분만 실제 DOM에 적용한다
    - UI를 업데이트 하는 과정에서 생기는 복잡함을 해소하여 쉽게 업데이트 할 수있지만, 복잡하지 않은 간단한 작업시에는 오히려 가상 DOM을 생성하는 과정이 딜레이를 초래할수 있다.

- [React에서 함수 컴포넌트와 클래스 컴포넌트의 차이 🔥](#React에서-함수-컴포넌트와-클래스-컴포넌트의-차이)
  - 클래스
    - 객체지향 프로그래밍 구조이며 초기화 하기위해 생성자(constructor) 함수를 필요로 함
    - 함수 컴포넌트에 비해서 코드가 길어지고, 사이즈가 커질 수 있어서, 메모리가 커지고 느려질 수 있음
    - state 기능 및 라이프 사이클 기능(componentDidMount, shouldComponentUpdate, componentDidUpdate, componentWillUnmount 등)을 사용할 수 있으며 임의 메서드를 정의할 수 있음
    - render 함수로 JSX를 반환 해야함
  - 함수 :
    - Hooks를 사용하여 생성자 함수를 통해 state를 초기화 안해도 사용가능
    - 클래스 컴포넌트에 비해 선언하기가 더 편하고, 사이즈가 적고, 메모리룰 덜 사용하여 빠르다
    - 커스텀 훅을 생성하여 동작 시킬 수있다
 
- [리액트에서 함수형 컴포넌트라고 부르지 않고 함수 컴포넌트라고 부르는 이유가 무엇인가요🔥](#리액트에서-함수형-컴포넌트라고-부르지-않고-함수-컴포넌트라고-부르는-이유가-무엇인가요)
  - 초창기에는 함수형 컴포넌트라 불렸지만 함수형 프로그래밍과 이름이 비슷하여 혼란스러울 수 있기 때문에 최근에 함수 컴포넌트로 이름이 바뀜.
  - 함수형 프로그래밍은 순수 함수를 지향하는데, 함수 컴포넌트는 훅으로 인해 많은 사이드 이펙트를 일으켜 함수형 프로그래밍과는 거리가 멀다

- [props와 state의 차이🔥](#props와-state의-차이)
  - props
    - 부모 컴포넌트에 있는 state가 자식 컴포넌트에 속성으로 설정되면, 자식 컴포넌트 내에서는 읽기전용 props가됨, 값을 바꾸려면 부모에서 바꿔야함
  - state
    - 컴포넌트 내부에서 바뀔수 있는 값

- [Props가 컴포넌트간에 전달받는 것이라고 했는데 자식에서 부모로도 전달할 수 있는가 🔥](#props가-컴포넌트간에-전달받는-것이라고-했는데-자식에서-부모로도-전달할-수-있는가)
  - 부모에서 자식으로만 가능
  - 자식에서 부모로 데이터 전송 방법 = 함수 이용 (부모는 함수를 전달하고, 자식은 파라미터로 값을 전달)

- [FLUX에 대해서 아나요? 🔥🔥](#FLUX에-대해서-아나요)
  - MVC 패턴
    - Model과 View간에 쌍방향 데이터 흐름 (Action -> Controller -> Model <-> View)
    - 간단한 어플리케이션의 경우 쉽게 데이터 흐름을 파악 할 수있으나, 기능들이 추가 될 수록 데이터 흐름이 복잡해짐 
  - FLUX 패턴 (리덕스)
    - 단방향 데이터 흐름 (Action -> Dispacher -> Store -> View -> Action ...)
    - 디스패처가 스토어를 업데이트하고 변경된 스토어에 대해 뷰를 렌더링, 뷰는 스토어에 직접 접근 할수 없고 디스패처로 다시 액션을 보내고 스토어를 업데이트한 뒤 다시 뷰를 리렌더링함
    - 단방향이어서 융통성은 없지만 기능이 추가되도 데이터 흐름을 파악하기 쉬움

- [리덕스에 대해서 아나요? 🔥](#리덕스에-대해서-아나요)
  - 상태관리 라이브러리 중 가장 많이 사용되는 라이브러리
  - Store라는 변수로 전역 상태관리를 하여 props를 주고 받지 않아도 됨

- [리덕스의 기본 3 원칙은? 🔥](#리덕스의-기본-원칙은)
  - 어플리케이션 상태는 모두 한곳에서 집중관리 (단일 저장소)
  - 상태는 읽기전용이며, Action을 통해서만 교체 가능 (예측가능, 디버깅 용이)
  - 부수효과 없는 순수 함수(Reducer)로 작성되어, 사실 상태를 변경하는게 아니라 새로운 상태 객체를 반환함

- [React에서 state의 불변성을 유지하라는 말이 있는데 이에 대해 설명해달라 🔥](#React에서-state의-불변성을-유지하라는-말이-있는데-이에-대해-설명해달라)
  - 객체는 복사하면 참조 값이 전달되어, 동일한 참조 값을 가진 객체중 하나라도 변경되면 모든 객체가 변경된다. 그래서 assign메서드나 스프레드 연산자로 불변성을 유지함(얕은복사)
  - 원본이 변경되면 부수효과에 의해 의도한 동작과 다르게 동작 할 수있다.

- [리듀서 내부에서 불변성을 지키는 이유는? 전개 연산자의 단점을 해결할 수 있는 방법은 무엇인가 🔥](#리듀서-내부에서-불변성을-지키는-이유는?-전개-연산자의-단점을-해결할-수-있는-방법은-무엇인가)
  - 불변성을 지킴으로 불필요한 리렌더링과 부수효과를 줄일 수 있다
  - 스프레드 연산자의 단점은 객체의 깊이에 따라 로직 구성이 어려울 수 있다는점, 이를위해 immer 라이브러리를 사용하여 produce, draft라는 키워드를 사용해서 기존의 spread 연산자를 사용하지 않고도 불변성을 유지해주며 불필요한 부수효과도 막아줍니다.

- [리액트 사용시에 부수효과로 인해 생기는 문제점이 있다면 🔥](#리액트-사용시에-부수효과로-인해-생기는-문제점이-있다면)
  - 부수 효과를 일으키는 함수 (불순 함수) 예시 : http 요청을 보내는 함수, prompt나 confirm등이 포함되있는 함수, 파라미터를 직접 변경하는 함수 등
  - 부수 효과를 일으키지 않는 함수 (순수 함수) : 항상 동일하게 예상된 값이 나오는 함수
  - 문제점 : 상태관리 어려워짐, 비동기 작업 처리 복잡해짐, 불필요한 렌더링 및 성능저하, 테스트 하기 어려움

- [컴포넌트의 라이프 사이클 메서드 🔥](#컴포넌트의-라이프-사이클-메서드)
  - 라이프 사이클 : 마운트, 업데이트, 언마운트
  - 업데이트가 되는 경우 : Props나 state의 변화, 부모 컴포넌트가 리렌더링, this.forceUpdate로 강제로 렌더링
  - 메서드 종류 (총 9가지)
    - 마운트 : componentDidMount 
    - 업데이트 : componentDidUpdate 
    - 언마운트 : componentWillUnmount 

- [Hooks의 종류 🔥](#Hooks의-종류)
  - useState
  - useEffect : 
    - 렌더링될 때마다 특정 작업을 수행하도록 (componontDidMount + componentDidUpdate)
    - useEffect에서 뒷정리(cleanup) 함수를 반환해 주면 컴포넌트가 언마운트 될시에 실행된다.
  - useReducer
    - useState보다 더 다양한 컴포넌트 상황에 따라 다양한 상태를 다른 값으로 업데이트 해주고 싶을 때 사용
    - useState Bank라 보면됨
  - useRef
      - useRef는 .current 프로퍼티에 변경가능한 값을 담고있으며, 프로퍼티가 변경되도 리렌더링을 유발하지 않는다.
      - 주로 리렌더링 없이 값만 내부에서 변경시키거나, DOM에 접근하기 위해 사용
  - useMemo
    - 처음 반환된 값을 메모이제이션하여 메모이제이션 된 값을 계속 사용하고, 두번째 인수 의존성 배열안에 값이 변경될때만 다시 변경된 값을 반환한다
    - 값이 객체타입이어도 변경되지 않은 주소 값을 메모이제이션해서 주소값이 바껴 재 렌더링 되는 현상이 일어나는 것을 방지한다
  - useCallback
    - 처음 반환된 함수를 메모이제이션하여 메모이제이션 된 함수를 계속 사용하고, 두번째 인수 의존성 배열안에 값이 변경될때만 다시 변경된 함수를 반환한다
    - 함수가 객체타입이지만 변경되지 않은 주소 값을 메모이제이션해서 주소값이 바껴 재 렌더링 되는 현상이 일어나는 것을 방지한다
  - 커스텀 Hooks

- [useMemo와 useCallback의 차이를 아나요 🔥](#useMemo와-useCallback의-차이를-아나요)
  - 리액트에서 리렌더링 되는 경우
    - props가 바뀔때
    - state가 바뀔때
    - 부모가 리렌더링 될때
  - useMemo : 메모이제이션 된 값을 반환
  - useCallback : 메모이제이션 된 함수를 반환
  - 불필요한 리렌더링은 성능 저하의 원인이 되지만, memoization은 메모리를 잡아먹기 때문에 이 두 hooks는 잦은 렌더링이 발생하거나 복잡한 로직이 수행될 때만 사용
 
-  React.memo란?
  - 고차 컴포넌트로, 컴포넌트의 결과 값을 메모이제이션하여 동일한 속성으로 여러번 호출될 땐 기억하고 있는 컴포넌트 값을 출력하고, 컴포넌트의 props가 변경될 때만 리렌더링이 되도록 최적화한다.
  - 객체타입은 주소값이 항상 변경되기 때문에 useMemo나 useCallback을 같이 사용하여 속성을 전달해줘야 한다.

- [리액트에서 setState는 비동기 동작인가요 동기 동작인가요?](#리액트에서-setState는-비동기-동작인가요-동기-동작인가요)
  - setState는 비동기 적으로 동작
  - 해당 함수 내에서 동기적으로 실행되는 함수가 모두 실행된 뒤에 마지막에 setState를 처리
  ```
  const onClickButton = () => {
    console.log("before", count); // ----> 동기함수
    setCount(count + 1); // ---->  비동기함수
    console.log("after", count); // ---->  동기함수
  };
  ```

- [setState가 비동기 동작을 취했을 때 얻을 수 있는 이점은 무엇인가요?](#setState가-비동기-동작을-취했을-때-얻을-수-있는-이점은-무엇인가요)
  - 리렌더링 횟수를 줄여 성능 향상에 도움 (실행컨텍스트에 동기적으로 실행되는 함수들을 모두 동작한 후, 큐에 존재하는 setState(비동기적인 함수)를 이벤트 루프에 의해 불려져서 실행

- [useLayoutEffect는 무엇인가요?](#useLayoutEffect를-사용해보신-적-있나요) : useEffect와는 호출 순서의 차이가 있음
  - 동기적으로 실행되므로 불필요한 렌더링을 방지하여 성능 최적화에 유용
  - useEffect와 useLayoutEffect의 차이
    - useEffect : 렌더링 될때 브라우저가 페인팅 하고 난 후에 실행됨, 주로 데이터 가져오기, API 호출 등과 같이, 화면을 먼저 보여지는게 더 효율적인 경우 사용
    - useLayoutEffect : 렌더링 될때 브라우저가 페인팅 하기 전에 실행, 주로 화면 요소의 레이아웃 리셋 등과 같이, DOM 조작이 렌더링 결과에 바로 반영되어야 하는 경우 사용
    ```
    import { useEffect, useState } from "react";
    
    export default  function App() {
      const [name, setName] = useState("");

      useEffect(() => {
        setName("영환");
      }, []);

      return (
        <>
          <div className="App">{`내 이름은 ${name} 입니다.`}</div>  // -> useEffect를 사용해서 빈칸이 먼저 보이고 이름이보임 이 경우 useLayoutEffect가 더 적합
        </>
      );
    }
    ```
 
- [리액트의 성능개선 방법에 대해서 설명해주세요](#리액트의-성능개선-방법에-대해서-설명해주세요)
  - 불필요한 렌더링 최소화
    - hook 함수 사용 (useMemo, useCallback)
    - React.memo
  - 코드 스플리팅
    - React.lazy() 함수와 Suspense 컴포넌트
    - Next.js 프레임워크 사용 
  - 메모리 누수 방지
    - 함수 컴포넌트에선 useEffect의 리턴과 클래스 컴포넌트에서는 componentWillUnmount()를 이용하여 컴포넌트가 언마운트 불필요한 이벤트 리스너, 타이머 등의 자원 해제를 수행
  - 그 외
    - key값으로 index를 사용하지 않는다
    - useTransition과 useDeferredValue로 성능저하를 일으키는 부분은 나중에 처리

- [컴포넌트에서 이벤트를 실행시키기 위해서는 어떻게 핸들링해야 하나요](#컴포넌트에서-이벤트를-실행시키기-위해서는-어떻게-핸들링해야-하나요)
  - 이벤트로 사용할 함수를 넣음 (직접 넣어 줄 때는 화살표 함수 문법을 사용)

- [SPA가 뭔가요](#SPA가-뭔가요)
  - SPA의 단점
- [SSR이 뭔가요](#SSR이-뭔가요)
  - 
- [SEO가 뭔가요](#SEO가-뭔가요)
  - TTV, TTI

- [하이드레이션에 대해 알고 있나요](#하이드레이션에-대해-알고-있나요)
  - 

- [Next의 렌더링 수행 방식](#Next의-렌더링-수행-방식)
  - 
- [Next를 쓴 이유가 있나요](#Next를-쓴-이유가-있나요)
  - 
- [Next를 구성하는 기본 설정 파일에 대해서 알고 있나요?](#Next를-구성하는-기본-설정-파일에-대해서-알고-있나요)
  - 
- [사전 렌더링을 위해 사용해 본 함수가 있나요](#사전-렌더링을-위해-사용해-본-함수가-있나요)
  - 

- [Suspense](#suspense)

- `suspense가 뭔가요?`
- `suspense로 가능한 것은 어떤 것들이 있나요?`
