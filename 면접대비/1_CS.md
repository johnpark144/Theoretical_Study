- `프로세스와 스레드 🔥`
   - 프로세스 : 운영체제로 부터 자원을 할당받은 작업의 단위, 
      - 어떤 프로그램을 실행 --> 해당 파일이 컴퓨터 메모리로 (동적 상태) [이 상태의 프로그램을 프로세스라함]
      - 즉 프로그램은 코드 덩어리 파일, 그 프로그램을 실행한 게 프로세스
      - 자신만의 고유 공간과 자원을 할당받아 사용

  - 스레드 : 프로세스가 할당받은 자원을 이용하는 실행 흐름의 단위
     -  프로세스보다 더 작은 실행 단위, 프로세스와 다르게 스레드 간 메모리를 공유
     -  빠른 컨텍스트 스위칭 및 프로세스들의 통신 시간, 방법 어려움 해소

( 프로그램 > 프로세스 > 스레드 )
  
  - 프로세스와 스레드의 차이
    - 프로세스 : 더 큰 단위, 독자적인 시스템 자원을 할당 받음
    - 스레드 : 작은 단위, 프로세스 내부에서 다른 메모리 영역을 같은 프로세스 내 다른 스레드와 공유

  - 프로세스 스레드 비유
    - 메모리는 요리사와 같고, 프로세스는 라면, 김밥, 햄버거 만들기 와 같고, 스레드는 물끓이기, 김말기, 패티굽기와 같음
    - 요리사가 많으면 작업이 빠름 (멀티코어), 일을 한군데에서 동시에 작업해도 빠름 (멀티 스레드)

- `싱글 스레드와 멀티 스레드 🔥`
  - 싱글 스레드 장단점
    - 장점 : 1) 자원접근에 대한 동기화를 신경안 써도 됨, 2) 스레드 간의 작업전환(context switching)을 요구 하지 않아 단순 계산 작업엔 멀티 스레드 보다 빠를 수 있음
    - 단점 : 1) 여러 CPU를 활용 못함, 2) 동시 작업 하는 느낌을 주지 못함
  - 멀티 스레드 장단점
    - 장점 : 1) 새로운 프로세스보다 기존 프로세스에서 스레드 생성하는게 더 빠름, 2) 프로세스의 자원과 상태를 공유하여 효율적, 3) 프로세스 작업전환보다 스레드의 작업전환이 더 빠름.
    - 단점 : 1) 하나의 스레드만 필요한 때는 스레드 간의 작업전환이 오히려 시간을 지연시키는 결과를 초래, 2) 스레드 스케쥴링을 신경써야 한다.

- `HTTP 🔥`
  - HTTP란 (HyperText Transfer Protocol) ? 웹과 서버간의 데이터를 주고 받기 위한 통신 프로토콜 (FTP는 파일전송용)
  - HTTP 프로토콜의 가장 큰 특징 : HTTP 프로토콜은 상태가 없는 (stateless) 프로토콜 즉 현 데이터 요청과 다음 데이터 요청이 서로 관련이 없음
  - HTTP 비유
    - 데이터는 택배, http는 트럭과 같음
    - "1122, dutch st, deerpark TX" 라고하면 우린 주소형식인지 바로 알지만, 컴퓨터는 일반 글씨로 판단하여 웹 형식 주소라고 HTTP라고 알려줌

  - URL (Uniform Resource Locators) 이란? 
    - 서버에 자원(resource)를 요청하기 위해 입력하는 영문 주소 href (protocol://hostname:port/pathname?search#hash) -> protocol://hostname:port부분을 origin이라고도 함
    - 숫자로 되어있는 IP주소보다 기억하기 쉬운 장점
    - DNS(Domain Name System)를 통해 host에 해당하는 실제 IP 주소로 변환하여 서버에 요청(Request)을 보냄
  - DNS의 장점
    - IP 주소가 바뀌어도 똑같은 도메인 주소로 사용가능

  - HTTP/1.1 과 HTTP/2.0의 차이
    - HTTP/1.1 : 기본적으로 커넥션 당 하나의 요청과 응답만 처리, 예를 들어 CSS 파일을 로드하는 link 태그, 이미지 파일을 로드하는 img 태그, 자바스크립트를 로드하는 script 태그 등에 의한 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 전송되어, 응답 시간이 증가하는 단점
    - HTTP/2.0 : 커넥션당 다중 요청/응답이 가능, 로드 속도가 약 50% 정도 빠름

  - HTTPS와 HTTP
    - HTTPS의 S는 secure을 의미
    - 내가 사이트에 보내는 정보를 암호화가 되어 3자가 못알아 보게 한다
    - 이로인해 접속한 사이트가 믿을 만한 곳인지 알려줌 (일반 HTTP 사이트인 경우 '!안전하지않다' 표시가뜸)

  - 대칭키와 비대칭키(공개키와 개인키)
    - 대칭키는 받는사람과 보내는사람이 암호화하는 방식을 공유하여 서로만 알게함, 문제점은 암호화 하는 방식도 누가 채가면 소용이 없게됨
    - 비대칭키는 공개키 A와 개인키 B와 같이 짝된 서로 다른키로 써만 복호화 되도록함, 그래서 A는 항상 공개되어 있는키고, B는 비공개되어 B를 가진 기관만 복호화 하게 함. (A끼리는 복       호화 되지 않아서 A가 전달될때 도중에 채가도 상관없음)
    - 비대칭키가 훨씬 안전하지만 컴퓨터에 더 부담을 주기 때문에 대부분 비대칭키를 쓰되 대칭키와 혼합하여 씀 (대칭키를 공유할 때에 주로 비대칭키를 사용)

- `쿠키 세션 🔥`
  - 쿠키, 세션 쓰는 이유 🔥🔥
    - HTTP는 필요할 때만 요청, 응답하는 비연결성이라는 특징이 있기에, 전에 기록이 있으면 재연결되도록 함. (예를 들면 다른 도메인 갔다 기존 사이트로 돌아와도 로그인 정보가 유지)

  - 쿠키란? 🔥🔥
    - HTTP의 일종으로 사용자가 어떤 웹 사이트를 방문한 경우, 그 사이트 서버에서 클라이언트에 저장하는 작은 기록 정보 파일이다.
    - 이름, 값, 만료일(저장 기간 설정), 경로 정보로 구성
    - 총 300개 쿠키, 한 도메인당 20개쿠키만 가짐, 하나의 쿠키는 4K능까지 저장가능
    - 클라이언트가 갖고있기 때문에 보안에 취약 (중요정보X), 악용 및 변질 가능
    - 사용예시 : 아이디, 비번 자동입력, 팝업창 다시보지 않기 등
    - 동작 순서 : 클라이언트의 요청 -> 서버에서 쿠키와 함께 응답 -> 나중에 클라이언트가 요청시 쿠키와 함께 요청 -> 쿠키에 의한 서버의 응답

  - 세션이란? 🔥🔥
    - HTTP 세션이란? 클라이이언트가 웹 서버에 연결된 순간부터 통신이 끝낼 때 까지의 기간
    - 일반적인 세션이란? 서버에 세션에 대한 정보를 쿠키로 클라이언트에게 주어, 서버가 클라이언트를 식별할 수 있도록 하는 방식 자체를 의미
    - 용량제한 X
    - 쿠키를 이용하여 클라이언트 마다 고유한 세션 ID 값을 부여 (웹브라우저 종료시 세션쿠키 삭제)
    - 동작 순서 : 클라이언트의 요청 -> 세션 정보를 서버 세션에 저장 후 세션 ID를 쿠키를 통해 클라이언트에 부여 -> 나중에 세션ID를 가진 클라이언트가 요청 -> 세션ID에 맞는 정보 전달

  - 쿠키와 세션의 차이 🔥🔥
    - 쿠키 : 1)클라이언트에 저장, 2) 보안 취약, 3) 만료기간이나 삭제전까지 살아있음, 4) 클라이언트에 요청시 속도 빠름
    - 세션 : 1)서버에 저장, 2) 비교적 안전, 3) 만료기간을 정할 순 있지만 보통 브라우저가 종료되면 만료기간 상관없이 삭제, 4) 서버에 있어서 비교적으로 느리다

- `CORS 🔥`
  - CORS란 
      - Cross Origin Resource Sharing의 약자로, 교차 출처 공유라는 의미하고 여기서 Origin은 scheme(프로토콜), host, port 로 이루어진 도메인을 의미
      - 브라우저가 SOP(Same Origin Policy)인 동일 출처 정책에 의해 디폴트로 똑같은 URL끼리만 데이터접근 가능하게 하고 해킹방지 차원에서 기존 사이트에서 다른 사이트로 요청이 못가게끔 하는데, CORS를 허용하면 그것을 풀어주는 역할을 함.
      - 백엔드 쪽에서 허락할 다른 출처들을 화이트 리스트 미리 명시해둠
      - 프론트 -> WithCredentials: true / 서버 -> Access-Control-Allow-Credentials: true , 허락할 도메인
      - CORS에서 보내는 두 종류는 simple-request와 preflight이 있는데, simple-request는 요청을 하되 통과못되면 데이터를 못 받아 오게하고, preflight는 put과 delete와 같은경우에 매우 예민하기 때문에 preflight 요청을 먼저 보내서 요청 자체를 허락받도록 하여 안전한지 확인.

  - CORS 문제 해결하기
      - 먼저 프론트에서 응답 헤더에 제대로 된 정보를 넣어는 지 확신(예를들면 Credentials 관련 설정을 했는지)
      - 해당 오류를 캡쳐해서 서버 개발자와 같이 확인해보는 방법
      - 그래도 안되면 프록시 서버 설정

- `클라우딩 서비스 (off-premise 방식)`
  - off-premise는 클라우드 방식이고, on-premise는 IDC 즉 개인데이터센터인 자체시설에 직접 서버, 네트워크, 방화벽 등을 유지하여 관리하는 방식
  - IaaS : 
      - 인프라(실제 서버, 운영체제, 네트워크, 가상화, 스토리지)를 제공 및 관리 (AWS, NCP 등)
      - 빈 가상 환경이므로 시스템 해체, 이식성이 용이
      - 일일이 다 설치 해야해서 설치가 어려워 불편하지만, 자유롭다
      - 운영비가 많이듬(모니터링, CI/CD, 테스팅 등을 내가 직접 다 관리해야하여 보통 DevOps개발자를 고용하게됨)
  - PaaS : 
      - 앱 개발 지원 도구 제공 (헤로쿠)
      - 이식성이 어려워서 특정 플랫폼에 종속 가능성이 있음
      - 어느정도 설치가 되워있어서 편하지만, 자유롭지 않음
      - 운영비 절감효과(모니터링, CI/CD, 테스팅 등을 알아서 되도록 세팅되 있음)
  - SaaS 🔥 : 
      - 서비스로서의 소프트웨어(Software-as-a-Service, SaaS)는 클라우드 애플리케이션과 기본 IT 인프라 및 플랫폼을 사용자에게 제공하는 완성된 클라우드 컴퓨팅 형태
      - SaaS의 예로는 Google Docs, Microsoft Office 365와 같은 소비자 대상 서비스와 인사 관리 소프트웨어, 콘텐츠 관리 시스템, 고객 관계 관리 툴, IDE(통합 개발 환경)를 제공하는 엔터프라이즈 서비스가 있습니다.
  - 비유
      - on-premise는 자기집, off-premise(클라우드)는 호텔 방 하나와 같음
      - IaaS(빈방) < PaaS(기본 빌트인) < SaaS(완성되어 사용가능)

- `개발 방법론 🔥`
  - 폭포수 방법론 (순서중심)
      - 폭포수가 내려가듯 순차적인 소프트웨어 개발 프로세스를 말함 (분석 -> 설계 -> 구현 -> 시험 -> 통합 -> 유지보수)
      - 전 단계가 수행되어 완료되기 전에는 다음 단계를 진행할 수 없도록 제한하는 것이 특징
  - 애자일 방법론 (CI/CD 중심)
      - 신속한 반복 작업을 통해 실제 작동 가능한 소프트웨어를 개발하여 지속적으로 제공하기 위한 소프트웨어 개발 방식
      - 계획을 따르기보다 변화에 대응하며, 상호작용 및 고객의 만족도를 개선 하는 것이 핵심

- `Cache 🔥`
  - 캐시란?
      - Cache는 프랑스어로 숨기다 라는 뜻을 가지는 단어인 cacher 에서 파생된 단어
      - 자주 필요한 데이터나 반복적으로 동일한 결과를 일시적으로 저장하여 전체적인 처리 속도를 향상
      - 메모리가 CPU의 처리 속도를 쫓아가지 못하여 CPU가 메모리를 기다려야 하는 병목현상을 완화하기 위해 CPU와 메인 메모리 사이에 크기는 작지만 속도가 빠른 캐시 메모리를 둠
      - 정적캐싱: 캐싱할것을 미리보냄, 동적캐싱: 요청받을때마다 캐시를 확인한후 없으면 보냄
- `CI/CD 🔥`
  - CI/CD란?
      - 애플리케이션 개발 단계부터 빌드까지 자동화하여 작은단위로 보다 자주 빈번하게 효율적으로 배포하는 방법 (빈번하지 않으면 나중에 한번 할때 merge시 충돌이 날 수밖에 없음)
      - 지속적인 통합, 지속적인 서비스 제공 및 배포
      - 개발 생산성 향상, 문제점 빠르게 발견, 새로운 코드 통합으로 인한 문제해결

- `CDN 🔥`
  - CDN(엣지)이란?
      - CDN(콘텐츠 전송 네트워크)은 지리적으로 분산된 여러 개의 서버
      - 사용자와 가까운 곳에서 전송함으로써 전송 속도를 높여 지연 시간을 줄임
      - 한 서버에 몰릴 요청을 분산시켜 서버 과부화 방지
      - 한 서버에 대역폭을 넓힐 필요가 없어서 오히려 대역폭 비용이 절감
      - CDN중 하나가 오류 생겨도 다른 CDN으로 연결되기 떄문에 안정적
      - 보안에도 도움이됨 (디도스와 같은 서버 공격의 방패역할, 좋은보안등급 제공 등 )

- `테스트(TDD) 🔥`
  - 테스트란? 어플리케이션이 요구사항에 맞게 동작하는지를 검증하는 행위
  - 테스트의 예
     - 버그 수정 및 리팩토링 후 영향받는 다른모듈의 실행 결과 확인
     - html/css를 작성후 렌더링된 결과 확인
     - 테스트된 코드를 배포한 후 배포 과정에서 발생한 문제가 없는지 확인
  - 테스트의 장점
     - 테스트가 없으면 어플리케이션이 복잡해질 수록 테스트 비용이 증가 
     - 유지보수에 용이
     - 에러나 버그를 일찍발견
  - 테스트의 단점
     - 코드량이 많아져서 배보다 배꼽이 커지는 경우가 될 수있음
     - 테스트를 한다고 다 실패하는 건 아님
     - 생산성의 저하될 수 있다

  - 유닛 테스트란?
     - 모듈(함수,클래스) 테스트
     - 작성 비용이 적고, 실행속도가 빠름
     - 문제가 생긴 부분을 비교적 정확하게 파악
  - 통합 테스트란?
     - 단위 테스트보다 큰 범위
     - 개별 모듈(함수/클래스)들이 연결되어 제대로 상호작용하는지를 테스트
     - 단위 테스트에 비해 문제가 생긴 부분을 비교적 파악하기가 어려움
  - E2E(인수) 테스트란?
      - 실제 사용자가 사용하는 것과 같은 전체 테스트
      - 실행속도가 느림

- `business logic 🔥`
  - business logic 이란?
      - 프로그램의 핵심 로직
      - 어떻게 데이터가 생성되고 저장되고 수정되는지를 정의한 것
      - ex) 장바구니에 있는 결제예정 금액이 물품이 추가됨에 따라 수정되는 로직
- `Snippet 🔥`
  - snippet 이란?
      - 재사용 가능한 소스 코드, 기계어, 텍스트의 작은 부분을 일컫는 프로그래밍 용어
      - 반복 타이핑을 회피할 수 있도록

- `웹팩 🔥`
  - 웹팩이란?
      - 최신 프런트엔드 프레임워크에서 가장 많이 사용되는 모듈 번들러 
      - 웹 애플리케이션을 구성하는 HTML, CSS, JavaScript, 이미지 등의 정적인 리소스를 모두 각각의 모듈로 보고 이를 조합하여 병합된 하나의 결과물을 만드는 도구
  - 모듈이란?
      - 특정 기능을 갖는 작은 코드 단위
      - 성격이 비슷한 기능들을 하나의 파일로 관리
      - 자바스크립트 모듈에만 국한되지 않고 웹 애플리케이션을 구성하는 모든 자원을 의미 (HTML, CSS, Javascript, Images, Font, etc..)

  - 모듈 번들링(빌드)이란?
      - 웹 애플리케이션을 구성하는 몇십, 몇백개의 자원들을 하나의 파일로 병합 및 압축 해주는 동작

  - 웹팩이 등장한 이유 웹팩의 이점
      - 파일 단위의 모듈들을 관리 (파일 구조가 복잡해져도 코드의 유지보수와 확장이 쉬워짐)
      - 파일 변환 (이미지, CSS 등과 같은 타입도 웹팩을 통해 모듈처럼 불러와 사용가능)
      - 번들링과 압축 (하나의 번들 파일로 만들어져 최적화된 파일 크기를 갖게 하여 성능 개선에 도움)
      - Tree Shaking (사용하지 않는 코드를 제거하여 필요한 코드만 포함된 결과물을 생성)
      - 개발 서버 제공 (새로고침 없이 실시간으로 수정된 내용을 브라우저에 반영하는 HMR(Hot Module Replacement) 기능을 지원)

  - 바벨이란?
      - 자바스크립트에서 지원하는 최신 문법 (ES6, ES7, ES8, ES9, ...) 들을 브라우저 환경에서 호환이 가능하도록 변환해주는 트랜스파일링 언어
  - 트랜스 파일이란?
      - 한 언어로 작성된 코드를 비슷한 수준의 추상화를 가진 다른언어로 변환 ex) es6 -> es5 / c++ -> c 
  - 웹팩의 주요 속성 4가지
      - entry : 빌드를 할 대상 파일의 위치
      - output : 엔트리에 들어온 파일을 번들링한 결과물의 파일 경로
      - loader : 빌드시 JS가 아닌 파일(css, 이미지, 폰트 등)을 결과에 포함될 수 있도록함, module이라는 이름사용, 로더 설정 하지 않은 경우 빌드시 파일들을 인식 못하여 에러발생
      - plugin : 웹팩의 기본적인 동작에 추가적인 기능을 제공하는 속성
      - loader는 파일을 해석하고 변환하는 과정에 관여(없으면 빌드시 에러), plugin은 해당 결과물의 형태를 바꾸는 역할(없으면 빌드시 에러 안나지만 결과물에 작동이 안됨)

- `타입과 인터페이스 🔥🔥🔥`
  - 동적 타이핑 : 변수의 타입을 미리 지정하지 않고, 런타임에 할당된 값에 따라 자동으로 타입이 결정 (자바스크립트)
  - 정적 타이핑 : 변수의 타입이 미리 지정되어 있어, 런타임 때 타입이 변경될 수 없음
  - 타입스크립트 이용하는 이유
      - 정적 타이핑을 지원하여 런타임 에러를 줄임
      - 프로토타입 메서드를 자동완성 하게하여 개발 효율을 높일 수있음
      - 코드의 유지 보수성을 높일 수 있음
  - 타입과 인터페이스의 차이
      - 확장 방법 : 인터페이스는 extends 키워드를 사용하여 확장이 가능하고, 타입은 & 연산자를 통해 확장이 가능하다
      - 선언적 확장 : 이미 존재하는 인터페이스와 같은 인터페이스 명으로 다시 만들면 자동확장, 타입은 Duplicate 에러 뜸
      - 인터페이스는 객체 타입용 (원시타입이 아닌 객체타입을 쓴다면 인터페이스를 추천)
  - 어떤 상황에서 타입을 쓰고 인터페이스를 쓰는지?
      - 
  - 제네릭이란?
      - 클래스, 함수, 인터페이스 등을 다양한 타입으로 재 사용가능하게 해주는 문법
         ```      
         // 제네릭 X
         function getSize(arr: number[] | string[] | boolean[]): number {  
           return arr.length;
         }

         const arr = [1, 2, 3];
         getSize(arr); 

         const arr2 = ["a", "b", "c"];
         getSize(arr2);
         ```  

         ``` 
         // 제네릭 O
         function getSize<T>(arr: T[]): number {   
           return arr.length;
         }

         const arr = [1, 2, 3];
         getSize<number>(arr);

         const arr2 = ["a", "b", "c"];
         getSize<string>(arr2);
         ```
