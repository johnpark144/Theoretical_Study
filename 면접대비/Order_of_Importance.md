- `호이스팅이란? 🔥🔥🔥🔥`
    - 호이스팅이란 변수나 함수 등이 어디에 위치하던지와 상관없이 <a href="">어디서든지 참조할 수 있게</a> 하는 것
    - 모든 선언문은 런타임 이전 단계에서 <a href="">끌어올려 먼저 실행</a>되기 때문에, <a href="">모든 식별자(변수, 함수, 클래스 등)가 호이스팅</a>이 된다
 
- `타입과 인터페이스 🔥🔥🔥`
  - 동적 타이핑 : 변수의<a href=""> 타입을 미리 지정하지 않고</a>, 런타임에 <a href="">할당된 값에 따라 자동으로</a> 타입이 결정 (자바스크립트)
  - 정적 타이핑 : 변수의 <a href="">타입이 미리 지정</a>되어 있어, 런타임 때 타입이 변경될 수 없음
  - 타입스크립트 이용하는 이유
      - <a href="">정적 타이핑을 지원</a>하여 런타임 에러를 줄임
      - <a href="">프로토타입 메서드를 자동완성</a> 하여 개발 효율을 높임
      - 코드의 <a href="">유지 보수성을 높임</a>
  - 타입과 인터페이스의 차이
      - 확장 방법 : <a href="">인터페이스는 extends 키워드</a>를 사용하여 확장이 가능하고, <a href="">타입은 & 연산자</a>를 통해 확장이 가능하다
      - 선언적 확장 : 이미 존재하는 인터페이스와 같은 <a href="">인터페이스 명으로 다시 만들면 자동확장</a>, <a href="">타입은 Duplicate 에러</a> 뜸
      - <a href="">인터페이스는 객체 타입용</a>
  - 어떤 상황에서 타입을 쓰고 인터페이스를 쓰는지?
      - 일반적으로, <a href="">변수, 함수, 매개변수, 반환값</a> 등을 정의할 때 <a href="">타입을 사용</a>하고, <a href="">객체 형태</a>를 정의할 때 <a href="">인터페이스를 사용</a>하는 것이 일반적
  - 제네릭이란?
      - <a href="">클래스, 함수, 인터페이스 등을 다양한 타입으로 재 사용가능</a>하게 해주는 문법
      
- `let과 var의 차이 🔥🔥🔥` : let은 ES6에서 도입하였으며 var의 문제점을 보완하였음
  - <a href="">let은 중복 선언 불가</a>
  - <a href="">let은 함수 레벨, 블록 레벨 스코프</a> (함수와 <a href="">if, for, while, try/catch문 모두 지역 스코프로 인정</a>)
  - let은 <a href="">변수 호이스팅이 발생하지 않는 것처럼</a> 동작함 (실제로는 호이스팅이 됨)
    
- `TDZ 🔥🔥🔥` : let과 const가 호이스팅은 되지만 선언문 이전에 사용 불가능 한 이유
  - 선언단계(<a href="">호이스팅되어 스코프 맨위에서 선언</a>) --> <a href="">일시적 사각지대(TDZ)</a> --> 초기화 단계(실제 선언문이 있는부분, undefined으로 초기화) --> 할당 단계
  - <a href="">var는</a> TDZ가 존재하지 않아 선언 단계가 곧 초기화 단계가 되어 <a href="">호이스팅되면 undefind가됨</a>
      
- `스코프란? 🔥🔥🔥`
  - <a href="">식별자(변수)가 유효한 범위</a>
    
- `클로저란? 🔥🔥🔥`
  - <a href="">함수가 선언될 당시의 환경을 계속 기억</a>하는 함수
  - <a href="">참조하는 식별자를 실행 컨텍스트가 종료되어도 렉시컬 환경을 통해 참조하고, 값을 변경</a>할 수 있게 하는 <a href="">체인 관계 구조</a>

- `태스크 큐와 이벤트 루프에 대해 🔥🔥🔥`
  - 태스크 큐: <a href="">비동기 함수의 콜백 함수</a> 또는 <a href="">이벤트 핸들러</a>가 대기실에 있다가 실행되려 할때 <a href="">일시보관되는 영역</a>이다, 먼저 push된 것이 먼저 shift되어 <a href="">F.I.F.O(First In First Out) 구조</a>를 띔,
  - 이벤트 루프: <a href="">콜 스택이 비어있는 경우</a>에 <a href="">태스크 큐에 대기 중인 함수를 콜 스택으로</a> 이동시킨다
      
- `쿠키, 세션 쓰는 이유 🔥🔥`
  - <a href="">HTTP는 비연결성</a>이라는 특징을 가짐
  - 그런데 이로인해 쿠키나 세션의 <a href="">기록이 있으면 재 연결</a>되도록 함.
    
- `쿠키란? 🔥🔥`
  - <a href="">기록 정보</a>
  - <a href="">클라이언트</a>에 저장하여 <a href="">속도가 빠르지만</a>, <a href="">보안에 취약</a>
  - <a href="">만료기간</a>이나 <a href="">삭제전</a>까지 살아있음
  - 사용예시 : 아이디, 비번 자동입력, 팝업창 다시보지 않기 등
  - 동작 순서 : 클라이언트의 요청 -> 서버에서 쿠키와 함께 응답 -> 나중에 클라이언트가 요청시 쿠키와 함께 요청 -> 쿠키에 의한 서버의 응답

- `세션이란? 🔥🔥`
  - 서버가 <a href="">클라이언트를 식별할 수 있도록</a> 하는 방식이고, <a href="">쿠키를 이용</a>하여 <a href="">클라이언트에 세션 ID 값을 부여</a>
  - <a href="">서버</a>에 저장하여 비교적 <a href="">느리지만</a>, <a href="">안전하다</a>
  - 만료기간을 정할 순 있지만 <a href="">보통 브라우저가 종료되면</a> 만료기간 상관없이 삭제
  - 동작 순서 : 클라이언트의 요청 -> 세션 정보를 서버 세션에 저장 후 세션 ID를 쿠키를 통해 클라이언트에 부여 -> 나중에 세션ID를 가진 클라이언트가 요청 -> 세션ID에 맞는 정보 전달
    
- `CSS 적용 우선순위(CSS cascading)🔥🔥`
  - 중요도 : 1) <a href="">태그내 style속성</a> 2) <a href="">style 태그</a> 3) style 태그 안 @import 4) link태그로 연결된 <a href="">css파일</a> 5) link태그로 연결된 css파일 안 @import
  - 명시도 :  1) <a href="">!important</a> 2) 태그내 style 3) <a href="">id</a>  4) <a href="">class</a> 5) <a href="">태그</a> 6) <a href="">전체 선택자(*)</a>
  - 코드순서 : <a href="">늦게 선언된</a> 스타일 우선 적용
  
- `const 🔥🔥`
  - <a href="">선언과 동시에 초기화</a>해야 한다 (undefined X)
  - <a href="">재할당 불가</a>
  - <a href="">상수</a>로 사용
    
- `스코프의 종류 🔥🔥`
  - 지역변수를 위한 <a href="">지역 스코프</a>와 전역변수를 위한 <a href="">전역 스코프</a>
    
- `함수형 프로그래밍이란? 🔥🔥`
  - 외부 상태에 영향받거나 주지않는 <a href="">순수 함수를 통해</a> 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 <a href="">안전성을 높이려는</a> 프로그래밍
- `순수 함수와 일반 함수 차이 🔥🔥`
  - 순수 함수는 입력이 같으면 항상 <a href="">같은 출력</a>을 반환하고, <a href="">외부 상태를 의존하지 않는</a> 부작용이 없는 함수
  - 일반 함수는 항상 같은 출력을 반환하지 않을 수 있으며, 외부 상태에 영향받을 수 있음
    
- `실행 컨텍스트에 대해 🔥🔥`
  - 코드를 실행하는 데 필요한 <a href="">환경을 제공하는 객체</a>, 식별자 결정을 더욱 효율적으로 하기 위한 수단
  - 렉시컬 환경은 실행 컨텍스트를 구성하는 하나의 컴포넌트로, 실행 컨텍스트는 <a href="">호출 스택(Call Stack)</a>에 쌓이며 <a href="">L.I.F.O(Last In First Out) 방식</a>대로 실행됩니다. 이 때, 호출된 함수의 <a href="">렉시컬 환경은 해당 함수의 스코프(Scope)를 결정</a>하게 됩니다.
    
- `클로저 장점 🔥🔥`
  - 상태가 의도치 않게 변경되지 않도록 <a href="">상태를 안전하게 은닉</a>하고 <a href="">특정 함수에게만 상태변경을 허용</a>
    
- `동기와 비동기의 차이 🔥🔥`
  - 동기식 : 태스크 순서대로 처리해서 <a href="">실행순서 보장</a>되지만, 태스크가 종료될 떄까지 이후 <a href="">태스크들이 블로킹</a>되는 단점이있음
  - 비동기식 : 태스크 <a href="">실행순서가 보장되지 않지만</a>, 태스크가 종료되지 않아도 <a href="">태스크들이 블로킹되지 않음</a> 
  - 대표적으로 <a href="">setTimeout/ setInterval</a>, <a href="">HTTP 요청</a>, <a href="">이벤트 핸들러</a>가 비동기식임

- `마이크로태스크 큐에 대해 🔥🔥`
  - <a href="">프로미스의 후속 처리 메서드(then, catch, finally)의 콜백 함수</a>는 태스크 큐 가 아니라 <a href="">마이크로태스크 큐</a>에 저장
    
- `태스크 큐와 마이크로태스크 먼저 실행 되는 것 🔥🔥`
  - <a href="">마이크로태스크 큐</a>는 태스크 큐보다 우선순위가 높다
    
- `FLUX에 대해서 아나요? 🔥🔥`
  - MVC 패턴
    - <a href="">Model과 View간에 쌍방향 데이터 흐름</a> (Action -> Controller => [Model <-> View])
    - <a href="">간단한 어플리케이션</a>의 경우 <a href="">쉽게 데이터 흐름을 파악</a> 할 수있으나, <a href="">기능들이 추가 될 수록 데이터 흐름이 복잡</a>해짐 
  - FLUX 패턴 (리덕스)
    - <a href="">단방향 데이터 흐름 (Action -> Dispacher -> Store -> View -> Action ...)</a>
    - 디스패처가 스토어를 업데이트하고 변경된 스토어에 대해 뷰를 렌더링, 뷰는 스토어에 직접 접근 할수 없고 디스패처로 다시 액션을 보내고 스토어를 업데이트한 뒤 다시 뷰를 리렌더링함
    - <a href="">단방향이어서 융통성은 없지만 기능이 추가되도 데이터 흐름을 파악하기 쉬움</a>
  - MVVM모델에 대해서
    - <a href="">View는 데이터 바인딩을 이용하여 ViewModel를 항상 구독</a>하고있고, ViewModel은 Model에 데이터 요청과 응답을 받음 <a href="">(Action -> View -> ViewModel <-> Model) </a>
    - ViewModel은 1개, View는 N개 (<a href="">1대다 관계</a>)
    - MVC와 다르게 <a href="">데이터 바인딩을 사용</a>하여 <a href="">View와 ViewModel 사이의 의존성을 없앤</a> 디자인 패턴이고, 이로인해 <a href="">로직이 복잡해져도</a> MVC보다 <a href="">유지보수가 쉽다</a>는 장점이있음.
    - MVVM은 <a href="">Angular, Vue.js, 플러터</a> 등 프레임워크에서 주로 쓰임
    
