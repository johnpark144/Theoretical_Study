- `호이스팅이란? 🔥🔥🔥🔥`
    - 호이스팅이란 변수나 함수 등이 어디에 위치하던지와 상관없이 <a href="">어디서든지 참조할 수 있게</a> 하는 것
    - 모든 선언문은 런타임 이전 단계에서 <a href="">끌어올려 먼저 실행</a>되기 때문에, <a href="">모든 식별자(변수, 함수, 클래스 등)가 호이스팅</a>이 된다
 
- `타입과 인터페이스 🔥🔥🔥`
  - 동적 타이핑 : 변수의<a href=""> 타입을 미리 지정하지 않고</a>, 런타임에 <a href="">할당된 값에 따라 자동으로</a> 타입이 결정 (자바스크립트)
  - 정적 타이핑 : 변수의 <a href="">타입이 미리 지정</a>되어 있어, 런타임 때 타입이 변경될 수 없음
  - 타입스크립트 이용하는 이유
      - <a href="">정적 타이핑을 지원</a>하여 런타임 에러를 줄임
      - <a href="">프로토타입 메서드를 자동완성</a> 하여 개발 효율을 높임
      - 코드의 <a href="">유지 보수성을 높임</a>
  - 타입과 인터페이스의 차이
      - 확장 방법 : <a href="">인터페이스는 extends 키워드</a>를 사용하여 확장이 가능하고, <a href="">타입은 & 연산자</a>를 통해 확장이 가능하다
      - 선언적 확장 : 이미 존재하는 인터페이스와 같은 <a href="">인터페이스 명으로 다시 만들면 자동확장</a>, <a href="">타입은 Duplicate 에러</a> 뜸
      - <a href="">인터페이스는 객체 타입용</a>
  - 어떤 상황에서 타입을 쓰고 인터페이스를 쓰는지?
      - 일반적으로, <a href="">변수, 함수, 매개변수, 반환값</a> 등을 정의할 때 <a href="">타입을 사용</a>하고, <a href="">객체 형태</a>를 정의할 때 <a href="">인터페이스를 사용</a>하는 것이 일반적
  - 제네릭이란?
      - <a href="">클래스, 함수, 인터페이스 등을 다양한 타입으로 재 사용가능</a>하게 해주는 문법
      
- `let과 var의 차이 🔥🔥🔥` : let은 ES6에서 도입하였으며 var의 문제점을 보완하였음
  - <a href="">let은 중복 선언 불가</a>
  - <a href="">let은 함수 레벨, 블록 레벨 스코프</a> (함수와 <a href="">if, for, while, try/catch문 모두 지역 스코프로 인정</a>)
  - let은 <a href="">변수 호이스팅이 발생하지 않는 것처럼</a> 동작함 (실제로는 호이스팅이 됨)
    
- `TDZ 🔥🔥🔥` : let과 const가 호이스팅은 되지만 선언문 이전에 사용 불가능 한 이유
  - 선언단계(<a href="">호이스팅되어 스코프 맨위에서 선언</a>) --> <a href="">일시적 사각지대(TDZ)</a> --> 초기화 단계(실제 선언문이 있는부분, undefined으로 초기화) --> 할당 단계
  - <a href="">var는</a> TDZ가 존재하지 않아 선언 단계가 곧 초기화 단계가 되어 <a href="">호이스팅되면 undefind가됨</a>
      
- `스코프란? 🔥🔥🔥`
  - <a href="">식별자(변수)가 유효한 범위</a>
    
- `클로저란? 🔥🔥🔥`
  - <a href="">함수가 선언될 당시의 환경을 계속 기억</a>하는 함수
  - <a href="">참조하는 식별자를 실행 컨텍스트가 종료되어도 렉시컬 환경을 통해 참조하고, 값을 변경</a>할 수 있게 하는 <a href="">체인 관계 구조</a>

- `태스크 큐와 이벤트 루프에 대해 🔥🔥🔥`
  - 태스크 큐: <a href="">비동기 함수의 콜백 함수</a> 또는 <a href="">이벤트 핸들러</a>가 대기실에 있다가 실행되려 할때 <a href="">일시보관되는 영역</a>이다, 먼저 push된 것이 먼저 shift되어 <a href="">F.I.F.O(First In First Out) 구조</a>를 띔,
  - 이벤트 루프: <a href="">콜 스택이 비어있는 경우</a>에 <a href="">태스크 큐에 대기 중인 함수를 콜 스택으로</a> 이동시킨다
      
- `쿠키, 세션 쓰는 이유 🔥🔥`
  - <a href="">HTTP는 비연결성</a>이라는 특징을 가짐
  - 그런데 이로인해 쿠키나 세션의 <a href="">기록이 있으면 재 연결</a>되도록 함.
    
- `쿠키란? 🔥🔥`
  - <a href="">기록 정보</a>
  - <a href="">클라이언트</a>에 저장하여 <a href="">속도가 빠르지만</a>, <a href="">보안에 취약</a>
  - <a href="">만료기간</a>이나 <a href="">삭제전</a>까지 살아있음
  - 사용예시 : 아이디, 비번 자동입력, 팝업창 다시보지 않기 등
  - 동작 순서 : 클라이언트의 요청 -> 서버에서 쿠키와 함께 응답 -> 나중에 클라이언트가 요청시 쿠키와 함께 요청 -> 쿠키에 의한 서버의 응답

- `세션이란? 🔥🔥`
  - 서버가 <a href="">클라이언트를 식별할 수 있도록</a> 하는 방식이고, <a href="">쿠키를 이용</a>하여 <a href="">클라이언트에 세션 ID 값을 부여</a>
  - <a href="">서버</a>에 저장하여 비교적 <a href="">느리지만</a>, <a href="">안전하다</a>
  - 만료기간을 정할 순 있지만 <a href="">보통 브라우저가 종료되면</a> 만료기간 상관없이 삭제
  - 동작 순서 : 클라이언트의 요청 -> 세션 정보를 서버 세션에 저장 후 세션 ID를 쿠키를 통해 클라이언트에 부여 -> 나중에 세션ID를 가진 클라이언트가 요청 -> 세션ID에 맞는 정보 전달
    
- `CSS 적용 우선순위(CSS cascading)🔥🔥`
  - 중요도 : 1) <a href="">태그내 style속성</a> 2) <a href="">style 태그</a> 3) style 태그 안 @import 4) link태그로 연결된 <a href="">css파일</a> 5) link태그로 연결된 css파일 안 @import
  - 명시도 :  1) <a href="">!important</a> 2) 태그내 style 3) <a href="">id</a>  4) <a href="">class</a> 5) <a href="">태그</a> 6) <a href="">전체 선택자(*)</a>
  - 코드순서 : <a href="">늦게 선언된</a> 스타일 우선 적용
  
- `const 🔥🔥`
  - <a href="">선언과 동시에 초기화</a>해야 한다 (undefined X)
  - <a href="">재할당 불가</a>
  - <a href="">상수</a>로 사용
    
- `스코프의 종류 🔥🔥`
  - 지역변수를 위한 <a href="">지역 스코프</a>와 전역변수를 위한 <a href="">전역 스코프</a>
    
- `함수형 프로그래밍이란? 🔥🔥`
  - 외부 상태에 영향받거나 주지않는 <a href="">순수 함수를 통해</a> 부수효과를 최대한 억제하여 오류를 피하고 프로그램의 <a href="">안전성을 높이려는</a> 프로그래밍
- `순수 함수와 일반 함수 차이 🔥🔥`
  - 순수 함수는 입력이 같으면 항상 <a href="">같은 출력</a>을 반환하고, <a href="">외부 상태를 의존하지 않는</a> 부작용이 없는 함수
  - 일반 함수는 항상 같은 출력을 반환하지 않을 수 있으며, 외부 상태에 영향받을 수 있음
    
- `실행 컨텍스트에 대해 🔥🔥`
  - 코드를 실행하는 데 필요한 <a href="">환경을 제공하는 객체</a>, 식별자 결정을 더욱 효율적으로 하기 위한 수단
  - 렉시컬 환경은 실행 컨텍스트를 구성하는 하나의 컴포넌트로, 실행 컨텍스트는 <a href="">호출 스택(Call Stack)</a>에 쌓이며 <a href="">L.I.F.O(Last In First Out) 방식</a>대로 실행됩니다. 이 때, 호출된 함수의 <a href="">렉시컬 환경은 해당 함수의 스코프(Scope)를 결정</a>하게 됩니다.
    
- `클로저 장점 🔥🔥`
  - 상태가 의도치 않게 변경되지 않도록 <a href="">상태를 안전하게 은닉</a>하고 <a href="">특정 함수에게만 상태변경을 허용</a>
    
- `동기와 비동기의 차이 🔥🔥`
  - 동기식 : 태스크 순서대로 처리해서 <a href="">실행순서 보장</a>되지만, 태스크가 종료될 떄까지 이후 <a href="">태스크들이 블로킹</a>되는 단점이있음
  - 비동기식 : 태스크 <a href="">실행순서가 보장되지 않지만</a>, 태스크가 종료되지 않아도 <a href="">태스크들이 블로킹되지 않음</a> 
  - 대표적으로 <a href="">setTimeout/ setInterval</a>, <a href="">HTTP 요청</a>, <a href="">이벤트 핸들러</a>가 비동기식임

- `마이크로태스크 큐에 대해 🔥🔥`
  - <a href="">프로미스의 후속 처리 메서드(then, catch, finally)의 콜백 함수</a>는 태스크 큐 가 아니라 <a href="">마이크로태스크 큐</a>에 저장
    
- `태스크 큐와 마이크로태스크 먼저 실행 되는 것 🔥🔥`
  - <a href="">마이크로태스크 큐</a>는 태스크 큐보다 우선순위가 높다
    
- `FLUX에 대해서 아나요? 🔥🔥`
  - MVC 패턴
    - <a href="">Model과 View간에 쌍방향 데이터 흐름</a> (Action -> Controller => [Model <-> View])
    - <a href="">간단한 어플리케이션</a>의 경우 <a href="">쉽게 데이터 흐름을 파악</a> 할 수있으나, <a href="">기능들이 추가 될 수록 데이터 흐름이 복잡</a>해짐 
  - FLUX 패턴 (리덕스)
    - <a href="">단방향 데이터 흐름 (Action -> Dispacher -> Store -> View -> Action ...)</a>
    - 디스패처가 스토어를 업데이트하고 변경된 스토어에 대해 뷰를 렌더링, 뷰는 스토어에 직접 접근 할수 없고 디스패처로 다시 액션을 보내고 스토어를 업데이트한 뒤 다시 뷰를 리렌더링함
    - <a href="">단방향이어서 융통성은 없지만 기능이 추가되도 데이터 흐름을 파악하기 쉬움</a>
  - MVVM모델에 대해서
    - <a href="">View는 데이터 바인딩을 이용하여 ViewModel를 항상 구독</a>하고있고, ViewModel은 Model에 데이터 요청과 응답을 받음 <a href="">(Action -> View -> ViewModel <-> Model) </a>
    - ViewModel은 1개, View는 N개 (<a href="">1대다 관계</a>)
    - MVC와 다르게 <a href="">데이터 바인딩을 사용</a>하여 <a href="">View와 ViewModel 사이의 의존성을 없앤</a> 디자인 패턴이고, 이로인해 <a href="">로직이 복잡해져도</a> MVC보다 <a href="">유지보수가 쉽다</a>는 장점이있음.
    - MVVM은 <a href="">Angular, Vue.js, 플러터</a> 등 프레임워크에서 주로 쓰임
    
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 < 예비 >
    
- `CORS 🔥`
    - CORS란 
      - Cross Origin Resource Sharing의 약자로, <a href="">교차 출처 공유</a>라는 의미
      - 여기서 Origin은 scheme(프로토콜), host, port 로 이루어진 도메인을 의미
      - <a href="">SOP</a>(Same Origin Policy)인 <a href="">동일 출처 정책</a>에 의해 <a href="">같은 URL끼리만 데이터접근 가능</a>하게 하지만 <a href="">CORS를 허용하면 그것을 풀어주는 역할</a>을 함(화이트리스트).
      - 프론트 -> WithCredentials: true / 서버 -> Access-Control-Allow-Credentials: true , 허락할 도메인
  - CORS 문제 해결하기
      - 먼저 프론트에서 응답 헤더에 제대로 된 정보를 넣어는 지 확신(예를들면 <a href="">Credentials 관련 설정</a>을 했는지)
      - 해당 오류를 캡쳐해서 <a href="">서버 개발자와 같이</a> 확인해보는 방법
      - 그래도 안되면 <a href="">프록시 서버 설정</a> 
    
- `브라우저 렌더링 과정 🔥`
  - 주소창에 Google.com을 입력하면?
    - <a href="">대기열</a>, <a href="">캐싱</a>, <a href="">DNS</a>, <a href="">라우팅</a>, <a href="">ARP</a>(IP에 해당하는 Mac주소 찾음), 초기연결을 거쳐 <a href="">서버로 부터 컨텐츠 다운</a>(response), <a href="">브라우저 렌더링</a> 발생 (캡슐화, 비캡슐화 과정을 거침)
  - 브라우저의 렌더링 과정 🔥
    - <a href="">서버에 요청</a> (주소창 입력 혹은 클릭을 통해 접근 <대기열, 캐싱 과정> -> URI를 DNS를 통해 IP 주소로 변환 -> 해당 IP를 가진 서버에 GET 요청)
    - 응답으로 받은 HTML <a href="">데이터를 파싱</a>
    - HTML 마크업을 바탕으로 <a href="">DOM 트리를 생성</a>
    - CSS 마크업을 바탕으로 <a href="">CSSOM 트리를 생성</a> (DOM 트리를 생성중 Style 태그가 나올시)
    - SCRIPT 마크업을 바탕으로 <a href="">AST (추상적 구문 트리) 생성</a> 후 실행 (DOM 트리를 생성중 SCRIPT 태그가 나올시)
    - DOM트리와 CSSOM트리를 결합하여 <a href="">렌더 트리를 형성</a>
    - 렌더 트리에서 <a href="">레이아웃을 설정</a> (HTML 요소의 레이아웃(위치 및 크기)를 계산)
    - 개별 노드를 화면에 <a href="">페인트</a> (레이아웃을 바탕으로 브라우저 화면에 픽셀을 렌더링)
    
- `식별자란(identifier)? 🔥`
    - 메모리 상에 존재하는 어떤 값을 식별할 수 있는 <a href="">고유한 이름들</a> (변수, 함수, 클래스 등)
    - 일반적으로 <a href="">영문,숫자,밑줄</a>로 구성 ex)myVar, total_num ...
    
- `프로토타입 🔥`
  - 객체지향 프로그래밍(OOP, Object Oriented Programing) 🔥
    - <a href="">절차지향적이 아닌</a> 독립적 단위, 즉 <a href="">객체의 집합으로 프로그램을 표현</a>하려는 프로그래밍
  - 객체지향 프로그래밍의 특징 🔥
    - <a href="">캡슐화 (Encapsulation)</a> : 데이터를 다루는 <a href="">방법과 목적에 따라 결합</a>, 변수와 함수를 하나로 묶음
    - <a href="">상속 (Inheritance)</a> : 포괄적으로 쓰이는 부모부분을 여러 자식들이 물려받아 동일하게 사용하게 함
    - <a href="">추상화 (Abstraciton)</a> : 객체의 다양한 속성 중 프로그램에 <a href="">필요한 속성만</a> 간추려 표현한 것 (클래스가 어떻게 동작하는지 다 알 필요는 없고 <a href="">사용자는 사용법만 알면됨</a>)
    - <a href="">다형성 (Polymorphism)</a> : 부모클레스에서 물려받은 가상 함수를 자식 클래스 내에서 <a href="">오버라이딩</a> 되어 <a href="">코드를 재사용</a>하는 것
  - 자바스크립트는 객체지향 프로그래밍 언어인가요?
    - <a href="">객체지향</a> 프로그래밍 + <a href="">함수형</a> 프로그래밍
    - 자바스크립트는 <a href="">클래스 기반 객체지향</a> (ES6), <a href="">프로토타입 기반 객체지향</a> (ES5 이전) 둘다 지원
  - 프로토타입이란?
    - 객체 간에 <a href="">상속을 구현하기 위해</a> 사용되는 객체이고, 그 객체를 참조하는 <a href="">숨겨논 링크</a>를 제공함
    - 마치 유전자와 같음
    
- `React 및 리듀서 내부에서 state의 불변성을 유지하라는 말이 있는데 이에 대해 설명해달라 🔥`
  - 객체는 복사하면 참조 값이 전달되어, <a href="">동일한 참조 값을 가진 객체중 하나라도 변경되면 모든 객체가 변경</a>된다.
  - <a href="">assign</a>메서드나 <a href="">스프레드 연산자</a> 는 객체의 <a href="">한 단계만 깊은복사</a> 그 이상은 <a href="">얕은복사</a>한다.
  - <a href="">immer 라이브러리</a>와 <a href="">lodash의 clone deep</a>과 <a href="">JSON.parse(JSON.stringify())</a> 등 으로 <a href="">완전한 깊은복사</a>를 할 수있다.
  - <a href="">원본이 변경되면</a> 이로인해 <a href="">부수효과에 의해 불필요한 리렌더링</a> 및 <a href="">의도한 동작과 다르게 동작</a> 할 수있다.

- `React에서 함수 컴포넌트와 클래스 컴포넌트의 차이 🔥`
  - 클래스
    - <a href="">객체지향 프로그래밍 구조</a>이며 초기화 하기위해 생성자(constructor) 함수를 필요로 함
    - 함수 컴포넌트에 비해서 <a href="">코드가 길어지고</a>, <a href="">사이즈가 커질 수 있어서</a>, <a href="">느려질 수 있음</a>
    - <a href="">state 기능</a> 및 <a href="">라이프 사이클 기능</a>(componentDidMount, shouldComponentUpdate, componentDidUpdate, componentWillUnmount 등)을 사용할 수 있으며 임의 메서드를 정의할 수 있음
    - <a href="">render 함수로 JSX를 반환 해야함</a>
  - 함수
    - <a href="">Hooks를 사용</a>하여 생성자 함수를 통해 state를 초기화 안해도 사용가능
    - 클래스 컴포넌트에 비해 <a href="">선언하기가 더 편하고</a>, <a href="">사이즈가 적고</a>, <a href="">빠르다</a>
    - <a href="">커스텀 훅</a>을 생성하여 동작 시킬 수있다
    
- `vue와 리액트의 차이점`
  - vue -> (프H 자빠진타 컴생)
    - <a href="">프레임워크</a>
    - <a href="">HTML, JS, CSS 코드 영역을 분리</a>해서 작성함
    - 정해진 방법만 사용하기 때문에 <a href="">자유도가 낮다</a> 그렇지만 리액트보다 <a href="">접근성이 높음</a>
    - 속도가 약간 더 <a href="">빠름</a>
    - <a href="">진입장벽이 낮음</a>
    - <a href="">타입스크립트로 구현이 좀 어려움</a>
    - <a href="">컴포넌트 분리 및 재사용</a> 측면에서 <a href="">효율성이 낮음</a>
    - 리액트보다 <a href="">생태계가 좁음</a>
  - 리액트
    - <a href="">라이브러리</a>
    - <a href="">JSX 형태</a> 코드를 사용함
    - 자바스크립트 코드를 더 사용하여 <a href="">자유도가 높다</a>는 장점이 있으나 그로인해 vue보다 <a href="">접근성이 낮다</a>
    - 속도가 vue보단 <a href="">약간 느림</a>
    - <a href="">진입장벽이 높음</a>
    - <a href="">타입스크립트로 구현이 쉬움</a>
    - <a href="">컴포넌트 분리 및 재사용</a> 측면에서 <a href="">효율성이 높음</a>
    - vue보다 <a href="">생태계가 넓음</a>
    
- `애자일 방법론` (<a href="">CI/CD 중심</a>)
      - <a href="">변화에 대응</a>하며, <a href="">상호작용</a> 및 <a href="">만족도 개선</a>을 위해 <a href="">반복작업</a>하는 개발 방식
    
- `bundle의 사이즈를 줄이려면`
     - <a href="">Tree-shaking</a> : <a href="">필요한 부분만</a> 추출하여 번들링하는 방식 (전체를 Import 하지 않고 사용하는 기능만 <a href="">{}</a> 부분적으로 Import )
     - <a href="">Code Splitting</a>
     - <a href="">이미지 최적화</a>
     - <a href="">라이브러리 최적화</a> : 라이브러리의 버전을 <a href="">최신 버전으로</a> 업데이트하거나, 필요한 부분만 가져와서 사용
     - <a href="">Gzip 압축</a>

- `웹팩이 등장한 이유 웹팩의 이점`
     - <a href="">파일 단위의 모듈들을 관리</a> (파일 구조가 복잡해져도 코드의 <a href="">유지보수와 확장이 쉬워짐</a>)
     - <a href="">파일 변환</a> (<a href="">이미지, CSS 등과 같은 타입도</a> 웹팩을 통해 <a href="">모듈처럼</a> 불러와 사용가능)
     - <a href="">번들링과 압축</a> (하나의 번들 파일로 만들어져 <a href="">최적화된 파일 크기를 갖게 하여 성능 개선</a>에 도움)
     - <a href="">Tree Shaking</a> (사용하지 않는 코드를 제거하여 필요한 코드만 포함된 결과물을 생성)
     - 새로고침 없이 <a href="">실시간으로 수정된 내용</a>을 브라우저에 반영하는 <a href="">HMR(Hot Module Replacement) 기능</a>을 지원
    
- `크로스 브라우징을 위해 고려할 수 있는 것`
    - <a href="">웹 표준 준수</a>
    - <a href="">CSS Reset</a> : 각 브라우저에는 margin, padding, line-height 등 각각 기본 스타일이 설정되어 있는데 그들을 초기화하여 <a href="">공통화</a> 시킴
    - <a href="">프리픽스 사용</a> : CSS 프리픽스를 사용하면 브라우저별로 각기 다른 CSS 속성값을 적용 (크롬,사파리:-webkit- / 파이어폭스:-moz- / 오페라:-o-)
    - 자바스크립트 <a href="">라이브러리 사용</a>
    - <a href="">폴리필 사용</a>
    - <a href="">테스트 및 디버깅</a>
    - <a href="">점유율이 높은 브라우저</a>부터 맞추는 것
    - <a href="">caniuse.com</a>로 기능 지원여부

- `HTML5의 특징 -> (멀모세로 웹캔위시)`
    - <a href="">멀티미디어</a> 지원 (audio태그, video태그)
    - <a href="">모든 디바이스</a> 웹페이지 호환
    - <a href="">세션 스토리지</a>와 <a href="">로컬 스토리지</a>
    - <a href="">웹소켓</a>
    - <a href="">캔버스</a>(2d,3d)
    - 지리적인 <a href="">위치 정보</a>
    - <a href="">시맨틱 태그</a>
     
- `float가 어떻게 작동 🔥`
  - float
    - CSS 위치지정 속성 (float 속성을 부여한 요소의 다음 요소는 <a href="">float 속성을 부여한 요소가 차지하는 위치만 제외하고 나머지 공간을 채우게함</a>,
    - <a href="">페이지의 흐름의 일부가 되어</a> 주로 페이지의 <a href="">텍스트와 이미지를 묶는 레이아웃</a>을 만들 때 사용 (position: absolute는 페이지의 흐름에서 제거)
    - <a href="">left, right, none 값</a> 중 하나를 가질 수 있다 (center나 middle 값은 없고 그렇게 이용하고 싶으면 margin:0 auto 로 이용)
    - position 속성의 absolute 값과 같이 쓰일 수 없고, <a href="">겹치면 absolute가 우선순위</a>임
  - clear
    - <a href="">left, right, both, none 값</a>을 float요소 주변 태그에 줌으로써 <a href="">float 영향 받지않게</a>함
    - 보통 both를 쓰면됨
     
- `CSS-in-JS 🔥`
  - <a href="">JavaScript 코드 안</a>에서 CSS를 작성하는 방법
  - <a href="">컴포넌트 단위로 스타일링</a>을 하기 때문에 코드 <a href="">유지보수가 용이</a>
  - 진정한 <a href="">분리 법칙</a>을 따른다 (CSS-in-JS의 경우 <a href="">부모 요소의 속성을 상속하지 않음</a>)
  - <a href="">네임스페이스 충돌이나 CSS 셀렉터 우선순위와 같은 문제 걱정없음</a>
  - <a href="">조건부 스타일링</a>이 쉽다
  - 코드가 길어지면 <a href="">가독성이 떨어질 수</a> 있다
  - 대표적인 라이브러리로 <a href="">styled-components</a>와 <a href="">Emotion</a>
    
- `this 🔥`
  - this란? 🔥
    - <a href="">자신이 생성할 인스턴스</a>를 가리키는 <a href="">자기 참조 변수</a>
    - this 바인딩은 함수 호출 방식에 의해 <a href="">동적으로 결정</a>된다.
  - this 바인딩이란? 🔥
    - <a href="">this가 가리킬 객체</a>와 바인딩하는 것
  - this는 동적으로 바인딩이 된다고 하는데 바인딩되는 객체가 어떻게 다른지?
    - <a href="">암시적 바인딩</a> : <a href="">함수를 호출 한 객체</a>와 바인딩 되는 것
    - <a href="">명시적 바인딩</a> : <a href="">call(), apply(), bind()</a> 함수로 <a href="">지정해서</a> 바인딩 해주는 것
    
- `Ajax란?`
    - 자바스크립트를 사용하여 브라우저가 서버에게 <a href="">비동기 방식으로 데이터를 요청</a>하고, 서버가 응답한 <a href="">데이터를 수신하여 웹페이지를 동적으로 갱신</a>하는 프로그래밍 방식

- `REST API란?`
    - REST는 HTTP를 기반으로 클라이언트가 <a href="">서버의 리소스에 접근하는 방식을 규정한 아키텍처</a>고, REST API는 REST를 기반으로 서비스 API를 구현한 것을 의미
    
- `콜백이란? 🔥`
    - 다른 함수의 <a href="">매개변수로 함수를 전달</a>하고, 어떠한 이벤트가 발생한 후 <a href="">매개변수로 전달한 함수가 다시 호출</a>되는 것을 의미
    - <a href="">비동기 방식의 함수</a>라고 할 수 있음
    
- `프로미스란? 🔥`
    - <a href="">콜백 헬과 같은 문제들을 해결</a>하기 위해 ES6에 고안된 <a href="">비동기식 처리 패턴</a>
    
- `모듈 🔥`
  - 모듈이란?
    - 애플리케이션을 구성하는 개별적 요소로서 <a href="">재사용 가능한 코드 조각</a>
    - <a href="">기능을 기준으로 파일 단위로 분리</a>하고, <a href="">자신만의 파일 스코프(모듈 스코프)를 가질 수 있어야</a> 한다.
    - 모듈은 기본적으로 <a href="">비공개 상태</a>이지만, <a href="">export로 공개가 필요한 자산에 한정하여 공개가 가능</a>하고, 공개(export)된 자산은 <a href="">import로 다른 모듈 스코프 내로 불러들여 재사용</a>할 수 있다
    - CommonJS 와 AMD(asynchronous module definition)가 ES6이전에 많이 사용됨, <a href="">CommonJS는 주로 서버 사이드 개발에서 여전히 많이 사용</a>됩니다.
    
- `css애니메이션과 JS애니메이션 차이`
  - Css애니메이션
    - <a href="">transition/animation</a> 속성 사용
    - <a href="">GPU 가속기능 지원</a>하여 <a href="">속도가 빠름</a>
    - 코드가 상대적으로 <a href="">간결함</a>    
    - <a href="">간단하게 처리하는 애니메이션</a>인경우 사용
    - <a href="">반응형에 유리</a>
  - JS애니메이션
    - <a href="">setInterval()/requestAnimationFrame()</a>을 사용
    - <a href="">CPU를 사용</a>해서 <a href="">상대적으로 느림</a>
    - 코드가 상대적으로 <a href="">복잡함</a>
    - css로 처리하기에 복잡하고 <a href="">무거운 애니메이션</a>인경우 사용
    - <a href="">크로스 브라우징 측면에서 유리</a>
     
- `심벌 타입이란?`
  - <a href="">유일하고 수정불가능한 식별자</a>를 만드는 데 사용 (<a href="">식별자 중복을 방지</a>하기 위한 용도)
  - ex) const mySymbolWithValue = Symbol('Hello');
     
- `데이터 타입이 필요한 이유 🔥`
  - <a href="">효율적으로 메모리 공간의 크기를 결정</a>하기 위해
  - <a href="">2진수를 어떻게 해석할지 결정</a>하기 위해
     
- `전역 객체`
  - 코드가 실행되기(런타임) 이전 단계에 자바스크립트 엔진에 의해 생성되는 <a href="">어떤 환경에서도 접근 가능한 특수한 객체</a>
  - 프로그램 전체에서 공유되는 <a href="">기본적인 기능들을 제공</a>
  - 브라우저에서는 window 객체, Node.js에서는 global 객체와 같은 <a href="">호스트 객체들도 전역 객체 중 하나</a>
    
- `리액트 사용시에 부수효과로 인해 생기는 문제점이 있다면 🔥`
  - <a href="">부수 효과를 일으키는</a> 함수 (<a href="">불순 함수</a>) 예시 : <a href="">http 요청</a>을 보내는 함수, <a href="">prompt나 confirm등이 포함</a>되있는 함수, <a href="">파라미터를 직접 변경</a>하는 함수 등
  - 부수 효과를 일으키지 않는 함수 (<a href="">순수 함수</a>) : 항상 동일하게 예상된 값이 나오는 함수
  - 문제점 : <a href="">상태관리 어려워짐</a>, <a href="">비동기 작업 처리 복잡해짐</a>, <a href="">불필요한 렌더링 및 성능저하</a>, <a href="">테스트 하기 어려움</a>
    
- `자바스크립트 성능 최적화를 위해 할 수 있는것 -> (메 이번 변비 코돔이네)`
  - 메모리 누수 방지
    - DOM 참조와 <a href="">클로저 사용을 자세히 관리</a>
    - 리액트에선 컴포넌트가 <a href="">언마운트시 자원해체</a>
  - 이미지 최적화
    - 이미지 크기를 조정
    - 이미지 포맷을 JPEG, GIF, PNG 등으로 바꿈
    - 이미지 스프라이트 기법을 사용
    - 벡터이미지 사용
  - 번들링과 압축
  - 변수 사용 최적화
    - <a href="">전역변수 및 불필요한 변수 생성 자제</a>
  - 비동기 프로그래밍
    - 콜백 함수나 프로미스, async/await 같은 <a href="">비동기 패턴을 사용하여 페이지 반응성을 높임</a>
  - 코드 실행 시간을 줄이기
    - for문 대신 forEach, map, filter 같은 <a href="">고차함수 사용</a>
    - <a href="">Memoization</a> 같은 최적화 기술을 사용
  - DOM 조작 최소화
    - <a href="">DOM 작업은 모아서</a> 하는 게 좋음
  - 이벤트 핸들러 관리
    - <a href="">이벤트 위임</a>을 사용
    - <a href="">이벤트 처리를 최소화</a>
  - 네트워크 요청 최소화
    - <a href="">Ajax 요청 통합</a>
    - <a href="">CDN</a>(Content Delivery Network)을 사용  

- `리액트의 성능개선 방법에 대해서 설명해주세요`
  - <a href="">렌더링 최적화</a>
    - <a href="">useMemo, useCallback</a>
    - <a href="">React.memo</a>
  - <a href="">코드 스플리팅</a>
    - <a href="">React.lazy()</a> 함수와 <a href="">Suspense</a> 컴포넌트
    - <a href="">Next.js</a> 프레임워크 사용
  - <a href="">메모리 누수 방지</a>
    - 함수 컴포넌트에선 <a href="">useEffect의 리턴</a>과 클래스 컴포넌트에서는 <a href="">componentWillUnmount()</a>를 이용하여 <a href="">컴포넌트가 언마운트시</a> 불필요한 이벤트 리스너, 타이머 등의 <a href="">자원 해제</a>를 수행
  - 그 외
    - <a href="">key값으로 index를 사용하지 않는다</a>
    - <a href="">useTransition과 useDeferredValue</a>로 <a href="">성능저하를 일으키는 부분은 나중에 처리</a>
    - <a href="">이미지 최적화</a>
    
- `Next를 쓴 이유가 있나요`
  - <a href="">사전 렌더링</a> 및 <a href="">서버사이드 렌더링</a> (<a href="">빠른 초기 로딩 속도</a>, <a href="">SEO</a>)
  - <a href="">Hot Code Reloading</a>, <a href="">HMR</a>(Hot Module Replacement) 지원 (<a href="">코드 수정 후 즉각적인 변경 사항 확인</a>)
  - <a href="">자동 코드 스플리팅</a> (코드분할하여 따로 렌더링)
  - <a href="">설정이 필요없음</a> (기본 <a href="">웹팩과 바벨</a>을 사용, 원하는 <a href="">플러그인 추가</a> 가능)
  - <a href="">타입스크립트</a> 내장
  - <a href="">파일기반 네비게이션</a> (리액트 라우터 없이, <a href="">폴더로 라우팅</a>)
  - <a href="">정적 파일 제공<a href=""> (<a href="">public 디렉토리</a>를 통해)
    
- `시스템 고도화를 위해 할 수 있는것`
  - <a href="">아키텍처 개선</a>
  - 인프라 업그레이드: <a href="">하드웨어나 소프트웨어 업그레이드</a> 및 <a href="">좋은 제품</a>으로 변경
  - 코드 <a href="">리팩토링</a>(중복이 별로없고 더 보기 좋은 코드 --> 비슷한 결과물)
  - <a href="">성능 최적화</a>(비슷한 양의 코드 --> 더 좋은 결과물)
  - <a href="">보안 강화</a>
  - <a href="">모니터링 개선</a>
